# MIMXRT1060 工业网关 — 通讯数据架构规范

> 版本：1.0
> 平台：NXP MIMXRT1062DVL6A (Cortex-M7 @ 600 MHz, 1 MB SRAM)
> 下行：2 路 CAN FD → 多台 LF/HF/UHF RFID 读写器
> 上行：Modbus TCP (以太网) + Modbus RTU (RS485) → 上位机 / SCADA / PLC

---

## 目录

1. [系统架构总览](#1-系统架构总览)
2. [硬件接口规划](#2-硬件接口规划)
3. [下行协议：CAN FD（网关 ↔ RFID 读写器）](#3-下行协议can-fd网关--rfid-读写器)
   - 3.1 物理层
   - 3.2 链路层 — CAN ID 定义
   - 3.3 传输层 — 分帧与重组
   - 3.4 应用层 — 帧格式
   - 3.5 标签数据 TLV 编码
   - 3.6 CRC16 校验规范
   - 3.7 命令集
   - 3.8 业务流程
4. [上行协议：Modbus TCP / RTU（网关 ↔ 上位机）](#4-上行协议modbus-tcp--rtu网关--上位机)
   - 4.1 寄存器映射总览
   - 4.2 网关全局寄存器
   - 4.3 读写器控制寄存器
   - 4.4 标签数据访问（邮箱机制）
   - 4.5 标签摘要表
   - 4.6 线圈定义
   - 4.7 离散输入
5. [内部数据模型](#5-内部数据模型)
   - 5.1 统一标签记录
   - 5.2 读写器状态
   - 5.3 标签去重策略
   - 5.4 消息路由
6. [健壮性与容错设计](#6-健壮性与容错设计)
   - 6.1 心跳与在线管理
   - 6.2 命令超时与重传
   - 6.3 拥塞控制
   - 6.4 异常处理矩阵
   - 6.5 看门狗策略
7. [性能指标与内存预算](#7-性能指标与内存预算)
8. [扩展性设计](#8-扩展性设计)
9. [附录](#9-附录)

---

## 1. 系统架构总览

### 1.1 设计目标

| 目标 | 要求 |
|------|------|
| 工业级健壮 | 无动态内存分配、无 panic 传播、全链路 CRC 校验、心跳监测、超时重传 |
| 高效 | CAN FD 64 字节载荷 + 2 Mbps 数据段、标签批量打包、DMA 驱动串口 |
| 可扩展 | 统一 TLV 编码适配 LF/HF/UHF、预留命令空间、读写器热插拔 |

### 1.2 系统拓扑

```
                        ┌──────────────────────┐
                        │    上位机 / SCADA     │
                        └───┬──────────────┬───┘
                            │              │
                   Modbus TCP         Modbus RTU
                   (以太网)           (RS485)
                            │              │
┌───────────────────────────┴──────────────┴────────────────────────┐
│                         工业网关 (RT1062)                          │
│                                                                    │
│   ┌────────────┐  ┌──────────┐  ┌──────────┐  ┌───────────────┐  │
│   │ Modbus     │  │ 设备管理  │  │ 标签引擎  │  │ 命令路由      │  │
│   │ TCP + RTU  │  │ 心跳/在线 │  │ 去重/聚合 │  │ Session 管理  │  │
│   └─────┬──────┘  └────┬─────┘  └────┬──────┘  └──────┬────────┘  │
│         └───────────────┴─────────────┴────────────────┘           │
│                              │                                     │
│              ┌───────────────┴────────────────┐                    │
│              │       消息路由核心              │                    │
│              │   优先级队列 + 异步调度         │                    │
│              └───────┬────────────────┬───────┘                    │
│                      │                │                            │
│              ┌───────┴──────┐  ┌──────┴────────┐                   │
│              │ CAN FD Bus 1 │  │ CAN FD Bus 2  │                   │
│              │ (FlexCAN3)   │  │ (SPI+MCP2518) │                   │
│              └───────┬──────┘  └──────┬────────┘                   │
└──────────────────────┼────────────────┼────────────────────────────┘
                       │                │
              ┌────────┴──────┐  ┌──────┴────────┐
              │ CAN FD Bus 1  │  │ CAN FD Bus 2  │
              │               │  │               │
              │ ┌──┐┌──┐┌──┐ │  │ ┌──┐┌──┐┌──┐ │
              │ │R1││R2││R3│ │  │ │R4││R5││R6│ │
              │ └──┘└──┘└──┘ │  │ └──┘└──┘└──┘ │
              │  LF  HF  UHF │  │  UHF UHF  HF │
              └───────────────┘  └───────────────┘
              (最多 30 节点)      (最多 30 节点)
```

### 1.3 RFID 读写器类型

| 类型 | Field1（主标识） | Field2（扩展数据） | 特有字段 | 典型长度 | 最大长度 |
|------|-----------------|-------------------|---------|---------|---------|
| **LF** 低频 | ID | User | — | 5-10B + 0-32B | 256B + 256B |
| **HF** 高频 | ID | User | — | 4-10B + 0-48B | 256B + 256B |
| **UHF** 超高频 | TID | EPC | 起始相位、结束相位 | 12-20B + 12-32B | 256B + 256B |

所有字段均为变长，每字段最长 256 字节。

---

## 2. 硬件接口规划

### 2.1 RT1062 资源分配

| 功能 | 硬件资源 | 外部器件 | 说明 |
|------|----------|---------|------|
| CAN FD Bus 1 | FlexCAN3（原生 CAN FD） | CAN FD 收发器 (TJA1443 / MCP2542FD) + 磁耦隔离 | 数据段 2 Mbps |
| CAN FD Bus 2 | LPSPI2 + MCP2518FD | CAN FD 收发器 + 磁耦隔离 | SPI 外挂 CAN FD 控制器 |
| Modbus TCP | ENET + KSZ8081（板载） | — | 100 Mbps，lwIP / smoltcp |
| Modbus RTU | LPUART3 + DMA | RS485 收发器 (MAX3485 / SP3485) | DE/RE 由 GPIO 控制 |
| 状态指示 | GPIO | LED ×4 | 运行 / CAN1 / CAN2 / 故障 |
| 看门狗 | RTWDOG | — | 任务级喂狗 |

### 2.2 CAN FD Bus 物理接口

```
网关端:
  RT1062 FlexCAN3 TX/RX ──→ 磁耦隔离器 ──→ TJA1443 (CAN FD 收发器)
                                              │
  RT1062 LPSPI ──→ MCP2518FD ──→ 磁耦隔离器 ──→ TJA1443
                                              │
总线:                                         │
  ──── 120Ω ════╤════╤════╤════╤════ 120Ω ──
                 │    │    │    │
                 R1   R2   R3   R4  (菊花链拓扑)
```

每条总线两端各一个 120Ω 终端电阻，共模扼流圈抑制高频噪声。

---

## 3. 下行协议：CAN FD（网关 ↔ RFID 读写器）

### 3.1 物理层

| 参数 | 值 | 说明 |
|------|------|------|
| 仲裁段波特率 | 500 kbps | 兼顾距离与兼容性 |
| 数据段波特率 | 2 Mbps | 长距离稳定（短距可选 5 Mbps） |
| 仲裁段采样点 | 80% | |
| 数据段采样点 | 70-75% | |
| 拓扑 | 菊花链总线 | |
| 终端电阻 | 两端各 120Ω | |
| 节点隔离 | 磁耦或光耦 | 工业必须 |
| 最大节点数 | 30 / 总线 | 含网关节点 |
| 最大总线长度 | 40m @ 2 Mbps | |

### 3.2 链路层 — CAN ID 定义（29-bit 扩展帧）

```
 Bit:  28  27  26 │ 25  24  23  22  21 │ 20  19  18  17  16  15  14  13 │ 12  11  10  9   8 │ 7   6   5   4   3   2   1   0
      ├──Priority──┤├────Msg Type───────┤├──────────Func Code────────────┤├────Dest ID───────┤├──────────Source ID────────────┤
         3 bit            5 bit                     8 bit                       5 bit                    8 bit
```

| 字段 | 位域 | 宽度 | 说明 |
|------|------|------|------|
| **Priority** | [28:26] | 3 bit | 优先级，0=最高，7=最低 |
| **MsgType** | [25:21] | 5 bit | 消息类型枚举 |
| **FuncCode** | [20:13] | 8 bit | 功能码 |
| **DestID** | [12:08] | 5 bit | 目标地址（网关=0x00，读写器=0x01-0x1E） |
| **SourceID** | [07:00] | 8 bit | 源地址 |

#### 3.2.1 Priority 定义

| 值 | 级别 | 用途 |
|----|------|------|
| 0 | 最高（保留） | 系统紧急 |
| 1 | 紧急 | 急停、安全告警 |
| 2 | 告警 | 设备故障告警 |
| 3 | 命令 | 网关下发命令/读写器命令响应 |
| 4 | 实时数据 | 标签流数据（UHF 批量上报） |
| 5 | 普通数据 | HF/LF 标签上报 |
| 6 | 配置 | 参数配置、OTA |
| 7 | 最低 | 心跳、状态广播 |

#### 3.2.2 MsgType 枚举

| 值 | 名称 | 方向 | 说明 |
|----|------|------|------|
| 0x00 | CMD_REQ | 网关→读写器 | 单帧命令请求 |
| 0x01 | CMD_RSP | 读写器→网关 | 单帧命令响应 |
| 0x02 | MFRM_START | 双向 | 多帧传输起始帧 |
| 0x03 | MFRM_FC | 双向 | 多帧流控帧 |
| 0x04 | MFRM_CONT | 双向 | 多帧连续帧 |
| 0x10 | TAG_SINGLE | 读写器→网关 | 单标签上报（自动感应触发） |
| 0x11 | TAG_STREAM | 读写器→网关 | 批量标签流（盘点模式） |
| 0x12 | TAG_EVENT | 读写器→网关 | 标签事件（进场/离场） |
| 0x1C | ALARM | 读写器→网关 | 告警帧 |
| 0x1D | OTA_DATA | 网关→读写器 | OTA 固件数据 |
| 0x1E | HEARTBEAT | 读写器→网关 | 心跳 |
| 0x1F | BROADCAST | 网关→全部 | 广播（DestID=0x1F） |

#### 3.2.3 CAN ID 编解码

```
编码: id = (priority << 26) | (msg_type << 21) | (func_code << 13)
        | (dest_id << 8) | source_id

解码: priority  = (id >> 26) & 0x07
      msg_type  = (id >> 21) & 0x1F
      func_code = (id >> 13) & 0xFF
      dest_id   = (id >>  8) & 0x1F
      source_id =  id        & 0xFF
```

### 3.3 传输层 — 分帧与重组（ISO-TP 适配）

CAN FD 单帧有效载荷 64 字节。当应用层数据超过单帧容量时启用多帧传输。

#### 3.3.1 单帧（Single Frame）

当应用层数据 ≤ **60 字节**（64 - 4 字节帧头）时，使用单帧直接发送。

#### 3.3.2 多帧起始帧（Multi-Frame Start）

```
Byte 0-1:  总数据长度 (LE, uint16, 最大 65535)
Byte 2-3:  Packet ID   (LE, uint16, 会话标识，用于并发重组)
Byte 4-63: 首批数据    (60 字节)
```

#### 3.3.3 流控帧（Flow Control）

接收方收到起始帧后回复：

```
Byte 0:    FC Flag     (0x00=Continue, 0x01=Wait, 0x02=Abort)
Byte 1:    BlockSize   (允许连续发送的帧数，0=不限制)
Byte 2:    STmin       (最小帧间隔，ms，0=无间隔)
```

#### 3.3.4 连续帧（Consecutive Frame）

```
Byte 0:    序号 (0-255 循环)
Byte 1-63: 后续数据 (63 字节/帧)
```

#### 3.3.5 多帧传输示例

512 字节标签数据（256B TID + 256B EPC 满载场景）：

```
帧 1 (MFRM_START): [总长=519][PktID=42][首批 60B 数据]     → 剩余 459B
帧 2 (MFRM_FC):    [Continue][BS=0][STmin=0]               ← 网关回复
帧 3 (MFRM_CONT):  [Seq=0][63B 数据]                       → 剩余 396B
帧 4 (MFRM_CONT):  [Seq=1][63B 数据]                       → 剩余 333B
帧 5 (MFRM_CONT):  [Seq=2][63B 数据]                       → 剩余 270B
帧 6 (MFRM_CONT):  [Seq=3][63B 数据]                       → 剩余 207B
帧 7 (MFRM_CONT):  [Seq=4][63B 数据]                       → 剩余 144B
帧 8 (MFRM_CONT):  [Seq=5][63B 数据]                       → 剩余 81B
帧 9 (MFRM_CONT):  [Seq=6][63B 数据]                       → 剩余 18B
帧 10(MFRM_CONT):  [Seq=7][18B 数据 + 45B 填充]            → 完成

共 10 帧（含流控），耗时 ≈ 4ms @ 2Mbps
```

#### 3.3.6 并发重组

网关可能同时接收多个读写器的多帧传输。通过 `SourceID + Packet ID` 二元组区分不同会话，支持最多 **4 路并发重组**。

### 3.4 应用层 — 帧格式

所有 CAN FD 帧的有效载荷（单帧或多帧重组后）遵循统一格式：

```
┌──────────────────────── 应用层 PDU ────────────────────────┐
│ Byte 0      │ SeqID       │ 序列号 (0-255 循环)            │
│ Byte 1      │ SubCmd      │ 子命令 / 标签计数               │
│ Byte 2      │ Status      │ 状态码 (响应帧有效, 请求帧=0)  │
│ Byte 3-4    │ DataLen     │ 后续有效数据长度 (LE, uint16)  │
│ Byte 5..N   │ Data        │ 业务数据 (命令参数/标签 TLV)   │
│ Byte N+1    │ CRC16-Hi    │ 应用层 CRC16 高字节            │
│ Byte N+2    │ CRC16-Lo    │ 应用层 CRC16 低字节            │
└─────────────┴─────────────┴────────────────────────────────┘

帧头:  5 字节 (SeqID + SubCmd + Status + DataLen)
帧尾:  2 字节 (CRC16)
固定开销: 7 字节
最大有效数据 (单帧): 64 - 7 = 57 字节
最大有效数据 (多帧): 65535 - 7 = 65528 字节
```

#### 3.4.1 Status 状态码定义

| 值 | 名称 | 说明 |
|----|------|------|
| 0x00 | OK | 成功 |
| 0x01 | ERR_PARAM | 参数错误 |
| 0x02 | ERR_BUSY | 读写器忙（正在执行其它命令） |
| 0x03 | ERR_NO_TAG | 无标签/标签不在场 |
| 0x04 | ERR_RF | 射频错误（天线断开、过热等） |
| 0x05 | ERR_AUTH | 认证失败（HF 密钥错误） |
| 0x06 | ERR_WRITE | 写入失败（标签锁定或损坏） |
| 0x07 | ERR_CRC | 应用层 CRC 校验失败 |
| 0x08 | ERR_OVERFLOW | 缓冲区溢出 |
| 0x09 | ERR_TIMEOUT | 操作超时 |
| 0x0A | ERR_UNSUPPORTED | 不支持的命令（如向 LF 发 UHF 命令） |
| 0xFE | ERR_INTERNAL | 内部错误 |
| 0xFF | ERR_UNKNOWN | 未知错误 |

### 3.5 标签数据 TLV 编码

标签数据以 TLV 格式编码在应用层 PDU 的 Data 区域内。

#### 3.5.1 单标签 TLV 结构

```
┌─ Tag TLV ──────────────────────────────────────────────────────┐
│ Byte 0:        TagType       (0x01=LF, 0x02=HF, 0x03=UHF)     │
│ Byte 1:        Antenna       (天线号 1-8)                      │
│ Byte 2-3:      RSSI          (LE, signed int16, dBm × 10)     │
│ Byte 4-5:      Phase Start   (LE, uint16, 0-3600 即 ×10°)     │
│ Byte 6-7:      Phase End     (LE, uint16, 0-3600 即 ×10°)     │
│ Byte 8-9:      Field1 Len    (LE, uint16, 0-256)              │
│ Byte 10..10+N1-1:  Field1 Data                                 │
│ Byte 10+N1..+1:    Field2 Len  (LE, uint16, 0-256)            │
│ Byte 10+N1+2..:    Field2 Data                                 │
└────────────────────────────────────────────────────────────────┘

固定开销: 10 字节 (TagType + Antenna + RSSI + Phase×2 + F1Len + F2Len)

LF/HF: Field1 = ID,  Field2 = User;  Phase Start/End = 0xFFFF（无效标记）
UHF:   Field1 = TID, Field2 = EPC;   Phase Start/End = 有效值 0-3600
```

#### 3.5.2 字段语义

| 读写器类型 | Field1 含义 | Field2 含义 | Phase | 去重主键 |
|-----------|------------|------------|-------|---------|
| LF (0x01) | 标签 ID | User 数据区 | 无效 (0xFFFF) | Field1 全部 |
| HF (0x02) | 标签 UID/ID | User 数据区 | 无效 (0xFFFF) | Field1 全部 |
| UHF (0x03) | TID | EPC | 有效 (0-3600) | Field1 全部 |

#### 3.5.3 单帧容量分析

单帧最大有效数据 57 字节，减去 TLV 固定开销 10 字节，可携带 F1+F2 ≤ 47 字节。

| 场景 | F1 | F2 | TLV 总长 | 帧数 |
|------|----|----|----------|------|
| LF 短 ID | 5B ID | 0B | 15B | 1（单帧） |
| HF 标准读取 | 4B UID | 16B User | 30B | 1（单帧） |
| UHF 典型 | 12B TID | 12B EPC | 34B | 1（单帧） |
| UHF 长数据 | 20B TID | 62B EPC | 92B | 2（多帧） |
| HF 长块读 | 10B ID | 256B User | 276B | 5（多帧） |
| 满载极限 | 256B | 256B | 522B | 9（多帧） |

#### 3.5.4 批量标签打包

TAG_STREAM 帧（MsgType=0x11）在 Data 区域中连续排列多个 Tag TLV：

```
Data = [Tag TLV 1][Tag TLV 2][Tag TLV 3]...

SubCmd(Byte 1) = 标签计数
DataLen = 所有 Tag TLV 的总长度
```

单帧可打包的标签数取决于各标签 TLV 大小。例如 UHF 典型（34B/标签）：`57 / 34 = 1` 个标签单帧。若需打包多个短标签（如 LF 15B/标签）：`57 / 15 = 3` 个标签单帧。

超出单帧容量时自动切换多帧传输。

### 3.6 CRC16 校验规范

#### 3.6.1 双层校验体系

| 层级 | 校验方式 | 覆盖范围 | 作用 |
|------|---------|---------|------|
| **链路层** | CAN FD 硬件 CRC | 整帧（仲裁+控制+数据） | 自动，由 CAN 控制器完成 |
| **应用层** | CRC16-Modbus | 帧头 + 数据（不含 CRC 本身） | 软件校验，防链路层未检出的残余错误 |

工业环境中仅依赖 CAN 硬件 CRC 不足够——多帧重组可能引入软件 bug、内存翻转（SEU）或 ISO-TP 层拼装错误。应用层 CRC 提供端到端完整性保障。

#### 3.6.2 CRC16-Modbus 算法

| 参数 | 值 |
|------|------|
| 多项式 | 0x8005 (x¹⁶ + x¹⁵ + x² + 1) |
| 初始值 | 0xFFFF |
| 输入反转 | 是（每字节 bit 反转） |
| 输出反转 | 是 |
| 最终异或 | 0x0000 |

选用 CRC16-Modbus 的原因：与上行 Modbus RTU 协议保持一致，共用同一套 CRC 校验代码。

#### 3.6.3 CRC 计算范围

```
CRC = CRC16_Modbus(Byte[0] .. Byte[N])
                    ├── SeqID ──┤
                    ├── SubCmd ─┤
                    ├── Status ─┤
                    ├── DataLen ┤
                    ├── Data... ┤
                    （不含 CRC 本身的 2 字节）

计算结果存放于 Byte[N+1] (高字节) 和 Byte[N+2] (低字节)
```

#### 3.6.4 校验失败处理

| 场景 | 处理 |
|------|------|
| 接收方 CRC 校验失败 | 丢弃该帧，不回复 ACK |
| 发送方超时未收到响应 | 按重传机制处理（见 6.2 节） |
| 连续 CRC 失败 ≥ 5 次 | 触发 ALARM，网关记录日志并上报 |

### 3.7 命令集

#### 3.7.1 系统命令（所有读写器类型通用）

| FuncCode | 命令名 | 方向 | 参数 | 响应 |
|----------|--------|------|------|------|
| 0x01 | GET_INFO | 网关→读写器 | 无 | 读写器类型(1B) + 固件版本(4B) + SN(16B) + 硬件型号(16B) |
| 0x02 | SET_BAUDRATE | 网关→读写器 | 仲裁段波特率(4B) + 数据段波特率(4B) | Status（需重启生效） |
| 0x03 | GET_STATUS | 网关→读写器 | 无 | 温度(1B) + 天线状态(1B) + 错误计数(2B) + 运行时间(4B) |
| 0x04 | RESET | 网关→读写器 | 复位类型: 0=软复位, 1=恢复出厂 | Status |
| 0x05 | SET_NODE_ID | 网关→读写器 | 新地址(1B) | Status（需重启生效） |
| 0x06 | SET_HEARTBEAT | 网关→读写器 | 间隔(2B, ms) | Status |
| 0x07 | SET_FIELD_FILTER | 网关→读写器 | F1 读取长度(2B) + F2 读取长度(2B) + F2 起始偏移(2B) | Status |
| 0x08 | SET_REPORT_INTERVAL | 网关→读写器 | 上报间隔(2B, ms) | Status |

#### 3.7.2 UHF 专用命令

| FuncCode | 命令名 | 参数 | 说明 |
|----------|--------|------|------|
| 0x10 | UHF_START_INV | AntMask(1B) + Mode(1B: 0=单次,1=连续) + Q(1B) + Session(1B) | 启动盘点 |
| 0x11 | UHF_STOP_INV | 无 | 停止盘点 |
| 0x12 | UHF_SET_POWER | ReadPower(2B, dBm×10) + WritePower(2B, dBm×10) | 设置功率 |
| 0x13 | UHF_READ_BANK | Bank(1B: 0=Reserved,1=EPC,2=TID,3=User) + Offset(2B) + Len(2B) + AccessPwd(4B) | 读存储区 |
| 0x14 | UHF_WRITE_BANK | Bank(1B) + Offset(2B) + Data(变长) + AccessPwd(4B) | 写存储区（多帧） |
| 0x15 | UHF_LOCK | LockMask(4B) + AccessPwd(4B) | 锁定标签 |
| 0x16 | UHF_KILL | KillPwd(4B) | 灭活标签 |
| 0x17 | UHF_SELECT | Target(1B) + Action(1B) + Bank(1B) + Pointer(2B) + Mask(变长) | 标签过滤 |

#### 3.7.3 HF 专用命令

| FuncCode | 命令名 | 参数 | 说明 |
|----------|--------|------|------|
| 0x20 | HF_READ_BLOCK | BlockAddr(2B) + BlockCount(1B) + KeyType(1B) + Key(变长, 6-16B) | 读块 |
| 0x21 | HF_WRITE_BLOCK | BlockAddr(2B) + Data(变长) + KeyType(1B) + Key(变长) | 写块（多帧） |
| 0x22 | HF_AUTO_SENSE | Enable(1B: 0=关闭, 1=开启) | 自动感应模式 |
| 0x23 | HF_AUTH | SectorAddr(1B) + KeyType(1B: 0=A, 1=B) + Key(6B) | 扇区认证 |
| 0x24 | HF_HALT | 无 | 停止当前标签通信 |

#### 3.7.4 LF 专用命令

| FuncCode | 命令名 | 参数 | 说明 |
|----------|--------|------|------|
| 0x30 | LF_READ_ID | 无 | 读取标签 ID |
| 0x31 | LF_READ_USER | Offset(2B) + Length(2B) | 读 User 区 |
| 0x32 | LF_WRITE_USER | Offset(2B) + Data(变长) | 写 User 区（多帧） |
| 0x33 | LF_AUTO_SENSE | Enable(1B) | 自动感应模式 |

#### 3.7.5 OTA 命令

| FuncCode | 命令名 | 参数 | 说明 |
|----------|--------|------|------|
| 0xF0 | OTA_START | FirmwareSize(4B) + CRC32(4B) + TargetType(1B) | 启动升级 |
| 0xF1 | OTA_DATA | Offset(4B) + Data(变长) | 固件数据包（多帧） |
| 0xF2 | OTA_VERIFY | 无 | 请求校验并切换固件 |
| 0xF3 | OTA_ABORT | 无 | 中止升级 |

#### 3.7.6 心跳帧格式

FuncCode=0x03, MsgType=HEARTBEAT, Priority=7

```
Byte 0:   SeqID
Byte 1:   读写器类型 (0x01=LF, 0x02=HF, 0x03=UHF)
Byte 2:   状态掩码:
           bit0 = RF 正常
           bit1 = 天线 1 连接
           bit2 = 天线 2 连接
           ...
           bit7 = 过温告警
Byte 3:   温度 (signed, ℃)
Byte 4-5: 在场标签数 (LE, uint16)
Byte 6-7: 错误计数 (LE, uint16, 自上电累计)
Byte 8-11: 运行时间 (LE, uint32, 秒)
Byte 12-13: CRC16
```

#### 3.7.7 告警帧格式

FuncCode=0x00, MsgType=ALARM, Priority=2

```
Byte 0:   SeqID
Byte 1:   告警码:
           0x01 = 天线断开
           0x02 = RF 过温
           0x03 = 供电异常
           0x04 = CAN 总线 Error Passive
           0x05 = 内部缓冲区溢出
           0x06 = 应用层 CRC 连续失败
Byte 2-5: 告警详情 (4 字节，告警码特定)
Byte 6-7: CRC16
```

### 3.8 业务流程

#### 3.8.1 UHF 连续盘点

```
网关                              UHF 读写器
  │                                    │
  │─── CMD_REQ [UHF_START_INV] ──────→│  优先级=3
  │    (AntMask=0x01, Mode=连续,       │
  │     Q=4, Session=0)                │
  │                                    │
  │←── CMD_RSP [Status=OK] ───────────│  优先级=3
  │                                    │
  │    (读写器启动 RF，标签进入 FIFO)  │
  │                                    │
  │←── TAG_STREAM [N 个标签 TLV] ─────│  优先级=4，每 50ms 或 FIFO 满
  │←── TAG_STREAM [N 个标签 TLV] ─────│
  │←── TAG_STREAM [N 个标签 TLV] ─────│
  │    ...                             │
  │                                    │
  │←── HEARTBEAT ─────────────────────│  优先级=7，每 1s
  │                                    │
  │─── CMD_REQ [UHF_STOP_INV] ───────→│  优先级=3
  │                                    │
  │←── CMD_RSP [Status=OK] ───────────│
```

#### 3.8.2 HF 精确读写

```
网关                              HF 读写器
  │                                    │
  │─── CMD_REQ [HF_READ_BLOCK] ──────→│  Block=5, Count=1, KeyA
  │                                    │
  │←── CMD_RSP [Status=OK,            │  单帧（数据 ≤ 57B）
  │     Data: Tag TLV (ID + User)]    │
  │                                    │
  │─── CMD_REQ [HF_WRITE_BLOCK] ─────→│  多帧（数据可能 > 57B）
  │         MFRM_START ──────────────→│
  │←──────── MFRM_FC (Continue) ──────│
  │         MFRM_CONT ──────────────→│
  │         ...                        │
  │                                    │
  │←── CMD_RSP [Status=OK] ───────────│
```

#### 3.8.3 LF/HF 自动感应

```
网关                              LF/HF 读写器
  │                                    │
  │─── CMD_REQ [AUTO_SENSE Enable] ──→│
  │                                    │
  │←── CMD_RSP [Status=OK] ───────────│
  │                                    │
  │    (标签进入感应区)                │
  │                                    │
  │←── TAG_SINGLE [Tag TLV] ──────────│  优先级=5, 主动上报
  │                                    │
  │    (标签离开感应区)                │
  │                                    │
  │←── TAG_EVENT [离场事件] ──────────│  优先级=5
```

---

## 4. 上行协议：Modbus TCP / RTU（网关 ↔ 上位机）

网关作为 **Modbus Slave**（TCP Server + RTU Slave），上位机通过标准 Modbus 功能码读写寄存器即可操控全部读写器和获取标签数据。

TCP 和 RTU 共享同一套寄存器映射，数据完全一致。

### 4.1 寄存器映射总览

| 区域 | 地址范围 | 功能码 | 用途 |
|------|---------|--------|------|
| **线圈** | 0x0000-0x02FF | FC01/05/15 | 开关控制（盘点启停、使能等） |
| **离散输入** | 0x0000-0x02FF | FC02 | 只读状态（在线、告警等） |
| **输入寄存器** | 0x0000-0x3FFF | FC04 | 只读（网关状态、读写器状态、标签摘要） |
| **保持寄存器** | 0x0000-0x3FFF | FC03/06/16 | 读写（配置参数、标签邮箱访问） |

### 4.2 网关全局寄存器

#### 4.2.1 保持寄存器（FC03/06/16）— 网关配置

基址: `0x0000`

| 偏移 | R/W | 名称 | 说明 |
|------|-----|------|------|
| 0x0000 | R | FW_VERSION_MAJOR | 固件主版本号 |
| 0x0001 | R | FW_VERSION_MINOR | 固件次版本号 |
| 0x0002 | R | FW_VERSION_PATCH | 固件补丁号 |
| 0x0003 | R | HW_VERSION | 硬件版本号 |
| 0x0004 | R | UPTIME_H | 运行时间高 16 位（秒） |
| 0x0005 | R | UPTIME_L | 运行时间低 16 位（秒） |
| 0x0006 | R/W | MODBUS_ADDR | Modbus 从站地址（RTU, 默认 1） |
| 0x0007 | R/W | MODBUS_BAUD | RTU 波特率编码（0=9600, 1=19200, 2=38400, 3=57600, 4=115200） |
| 0x0008 | R/W | TAG_STALE_TIMEOUT | 标签老化超时（ms，默认 3000） |
| 0x0009 | R/W | TAG_REMOVE_TIMEOUT | 标签移除超时（ms，默认 10000） |
| 0x000A | R/W | GLOBAL_REPORT_INTERVAL | 全局默认上报间隔（ms） |

#### 4.2.2 输入寄存器（FC04）— 网关状态

基址: `0x0000`

| 偏移 | 名称 | 说明 |
|------|------|------|
| 0x0000 | ONLINE_READERS | 当前在线读写器总数 |
| 0x0001 | ONLINE_READERS_BUS1 | Bus 1 在线读写器数 |
| 0x0002 | ONLINE_READERS_BUS2 | Bus 2 在线读写器数 |
| 0x0003 | TOTAL_TAGS | 当前在场标签总数 |
| 0x0004 | TAGS_LF | LF 标签数 |
| 0x0005 | TAGS_HF | HF 标签数 |
| 0x0006 | TAGS_UHF | UHF 标签数 |
| 0x0007 | BUS1_LOAD | Bus 1 负载率（0-1000, ‰） |
| 0x0008 | BUS2_LOAD | Bus 2 负载率（0-1000, ‰） |
| 0x0009 | BUS1_ERR_COUNT | Bus 1 累计错误帧数 |
| 0x000A | BUS2_ERR_COUNT | Bus 2 累计错误帧数 |
| 0x000B | CRC_FAIL_COUNT | 应用层 CRC 校验失败累计 |
| 0x000C | MCU_TEMP | MCU 温度（signed, ℃） |
| 0x000D | TAG_NEW_COUNT | 自上次读取后新增标签数（读后清零） |
| 0x000E | TAG_REMOVE_COUNT | 自上次读取后移除标签数（读后清零） |
| 0x000F | ALARM_FLAGS | 告警标志位（见离散输入定义） |

### 4.3 读写器控制寄存器

每读写器占 **128 个保持寄存器** + **64 个输入寄存器**。

最大支持 60 个读写器（每总线 30 个）。

#### 4.3.1 保持寄存器（FC03/06/16）— 读写器配置

基址: `0x0100 + reader_index × 0x0080`（reader_index = 0-59）

| 偏移 | R/W | 名称 | 说明 |
|------|-----|------|------|
| +0x00 | R/W | READER_TYPE | 读写器类型: 1=LF, 2=HF, 3=UHF（配置后锁定） |
| +0x01 | R/W | READER_BUS | 总线号: 0=Bus1, 1=Bus2 |
| +0x02 | R/W | READER_CAN_ID | CAN 节点地址 (0x01-0x1E) |
| +0x03 | R/W | ANT_MASK | 天线掩码 bit0-7 对应 ANT1-8 |
| +0x04 | R/W | TX_POWER | 发射功率 (dBm × 10)，UHF: 0-330 |
| +0x05 | R/W | INV_MODE | 盘点模式: 0=单次, 1=连续, 2=自动感应 |
| +0x06 | R/W | UHF_Q | UHF Q 值 (0-15) |
| +0x07 | R/W | UHF_SESSION | UHF Session (0-3) |
| +0x08 | R/W | REPORT_INTERVAL | 上报间隔（ms） |
| +0x09 | R/W | HEARTBEAT_INTERVAL | 心跳间隔（ms，默认 1000） |
| +0x0A | R/W | F1_READ_LEN | Field1 读取长度（0=全部, 1-256） |
| +0x0B | R/W | F2_READ_LEN | Field2 读取长度（0=全部, 1-256） |
| +0x0C | R/W | F2_OFFSET | Field2 读取起始偏移 |
| +0x0D | R/W | AUTO_SENSE_EN | 自动感应使能: 0=关, 1=开 |
| +0x0E-0x0F | R/W | 预留 | 扩展用 |

写入配置后，网关自动将对应参数通过 CAN FD 下发至目标读写器。

#### 4.3.2 输入寄存器（FC04）— 读写器状态

基址: `0x0100 + reader_index × 0x0040`

| 偏移 | 名称 | 说明 |
|------|------|------|
| +0x00 | ONLINE | 在线状态: 0=离线, 1=在线 |
| +0x01 | READER_TYPE | 读写器实际类型（从心跳帧获取） |
| +0x02 | TEMPERATURE | 温度（signed, ℃） |
| +0x03 | ANT_STATUS | 天线连接状态 bit mask |
| +0x04 | ERR_COUNT | 通信错误累计 |
| +0x05 | LAST_HB_H | 最后心跳时间高 16 位（ms） |
| +0x06 | LAST_HB_L | 最后心跳时间低 16 位（ms） |
| +0x07 | TAG_COUNT | 该读写器名下在场标签数 |
| +0x08 | INV_STATE | 盘点状态: 0=停止, 1=运行中 |
| +0x09 | ALARM_CODE | 最近告警码（0=无告警） |
| +0x0A | FW_VER_MAJOR | 读写器固件版本（主） |
| +0x0B | FW_VER_MINOR | 读写器固件版本（次） |
| +0x0C-0x0F | 预留 | |

### 4.4 标签数据访问（邮箱机制）

标签字段为变长（最大 256 字节），无法用固定寄存器覆盖。采用 **"指针写入 → 数据窗口读出"** 的邮箱模式。

#### 4.4.1 邮箱控制寄存器（保持寄存器）

基址: `0x2000`

| 偏移 | R/W | 名称 | 说明 |
|------|-----|------|------|
| 0x2000 | W | MB_TAG_INDEX | 目标标签索引 (0-MAX_TAGS) |
| 0x2001 | W | MB_FIELD_SEL | 字段选择: 0=摘要, 1=Field1, 2=Field2, 3=全部 |
| 0x2002 | W | MB_OFFSET | 字节偏移（分段读取长数据时使用） |
| 0x2003 | W | MB_TRIGGER | 写入任意值触发加载（写入后网关将数据填入窗口） |

#### 4.4.2 邮箱数据窗口（保持寄存器，只读区域）

基址: `0x2010`

| 偏移 | 名称 | 说明 |
|------|------|------|
| 0x2010 | MB_STATUS | 窗口状态: 0=加载中, 1=就绪, 0xFF=无效索引 |
| 0x2011 | MB_TAG_TYPE | 读写器类型: 1=LF, 2=HF, 3=UHF |
| 0x2012 | MB_READER_ID | 来源读写器 CAN ID |
| 0x2013 | MB_ANTENNA | 天线号 |
| 0x2014 | MB_RSSI | RSSI (signed, dBm × 10) |
| 0x2015 | MB_PHASE_START | 起始相位 (0-3600, ×10°; LF/HF=0xFFFF) |
| 0x2016 | MB_PHASE_END | 结束相位 (0-3600, ×10°; LF/HF=0xFFFF) |
| 0x2017 | MB_READ_COUNT | 读取次数（去重后累计） |
| 0x2018 | MB_STATE | 标签状态: 0=New, 1=Updated, 2=Stale, 3=Removed |
| 0x2019 | MB_FIRST_SEEN_H | 首次发现时间高 16 位（ms） |
| 0x201A | MB_FIRST_SEEN_L | 首次发现时间低 16 位（ms） |
| 0x201B | MB_LAST_SEEN_H | 最后更新时间高 16 位（ms） |
| 0x201C | MB_LAST_SEEN_L | 最后更新时间低 16 位（ms） |
| 0x201D | MB_F1_TOTAL_LEN | Field1 总长度（字节） |
| 0x201E | MB_F2_TOTAL_LEN | Field2 总长度（字节） |
| 0x201F | MB_F1_RETURN_LEN | 本次窗口中 Field1 返回长度 |
| 0x2020 | MB_F2_RETURN_LEN | 本次窗口中 Field2 返回长度 |
| 0x2021-0x2090 | MB_F1_DATA | Field1 数据 (最多 224 字节 = 112 寄存器) |
| 0x2091-0x2110 | MB_F2_DATA | Field2 数据 (最多 256 字节 = 128 寄存器) |

#### 4.4.3 上位机读标签流程

```
步骤 1: 读 Input[0x0003] → 获取在场标签总数 (例: 85)

步骤 2: 写 Holding[0x2000] ← 标签索引 (例: 0)
        写 Holding[0x2001] ← 字段选择 (3=全部)
        写 Holding[0x2002] ← 偏移 (0)
        写 Holding[0x2003] ← 任意值 (触发加载)

步骤 3: 轮询 Holding[0x2010]，等待 MB_STATUS = 1 (就绪)

步骤 4: 批量读 Holding[0x2011..0x2110] → 获取完整标签数据

步骤 5: 检查 MB_F1_TOTAL_LEN 和 MB_F2_TOTAL_LEN
        若 > 窗口容量，修改 MB_OFFSET 重复步骤 2-4 读取后续分段

步骤 6: 索引 +1，重复步骤 2-5 遍历所有标签
```

### 4.5 标签摘要表

用于上位机快速扫描全部在场标签，无需逐个触发邮箱。

**输入寄存器（FC04）**，基址: `0x3000`

每标签占 **10 个寄存器**（20 字节），共支持 256 个标签摘要。

| 偏移 | 名称 | 高字节 | 低字节 |
|------|------|--------|--------|
| +0 | TAG_TYPE_STATE | 读写器类型 (高 4 bit) | 标签状态 (低 4 bit) |
| +1 | READER_ANT | 读写器 ID (高 8 bit) | 天线号 (低 8 bit) |
| +2 | RSSI | RSSI (signed, dBm × 10) | |
| +3 | READ_COUNT | 读取次数 | |
| +4 | PHASE_START | 起始相位 (0-3600; LF/HF=0xFFFF) | |
| +5 | PHASE_END | 结束相位 (0-3600; LF/HF=0xFFFF) | |
| +6 | F1_PREFIX_0_1 | Field1[0] | Field1[1] |
| +7 | F1_PREFIX_2_3 | Field1[2] | Field1[3] |
| +8 | LAST_SEEN_H | 最后更新时间高 16 位 | |
| +9 | LAST_SEEN_L | 最后更新时间低 16 位 | |

标签摘要地址计算: `addr = 0x3000 + tag_index × 10`

上位机单次 FC04 最多读 125 寄存器 = 12 个标签摘要。读 256 个标签需 ~22 次请求。

Field1 前 4 字节（F1_PREFIX）用于快速识别标签（EPC 前缀、ID 前缀等），无需全量加载邮箱即可判断是否为目标标签。

### 4.6 线圈定义（FC01/05/15）

| 地址 | 名称 | 说明 |
|------|------|------|
| 0x0000 | GLOBAL_INV_START | 全局盘点启停（写 1 启动所有已配置读写器） |
| 0x0001 | BUS1_ENABLE | CAN Bus 1 使能 |
| 0x0002 | BUS2_ENABLE | CAN Bus 2 使能 |
| 0x0003 | TAG_CLEAR | 清空标签缓存（写 1 触发，自动归零） |
| 0x0004 | ERR_CLEAR | 清零所有错误计数 |
| 0x0005 | ALARM_ACK | 告警确认（清除当前告警） |
| 0x0010-0x004B | READER_INV[0-59] | 单个读写器盘点启停 (0x0010 + reader_index) |
| 0x0050-0x008B | READER_RESET[0-59] | 单个读写器软复位 (0x0050 + reader_index) |
| 0x00C0-0x00FB | READER_AUTO_SENSE[0-59] | 单个读写器自动感应使能 (0x00C0 + reader_index) |

### 4.7 离散输入（FC02）

只读状态位：

| 地址 | 名称 | 说明 |
|------|------|------|
| 0x0000 | GW_RUNNING | 网关运行中 |
| 0x0001 | BUS1_OK | Bus 1 正常 |
| 0x0002 | BUS2_OK | Bus 2 正常 |
| 0x0003 | ETH_LINK | 以太网链路连接 |
| 0x0004 | ALARM_ACTIVE | 有未确认告警 |
| 0x0005 | TAG_OVERFLOW | 标签存储已满 |
| 0x0010-0x004B | READER_ONLINE[0-59] | 读写器在线状态 |
| 0x0050-0x008B | READER_ALARM[0-59] | 读写器告警状态 |

---

## 5. 内部数据模型

### 5.1 统一标签记录

```rust
/// 读写器频段类型
#[derive(Clone, Copy, PartialEq, Debug)]
#[repr(u8)]
pub enum ReaderType {
    LF  = 0x01,
    HF  = 0x02,
    UHF = 0x03,
}

/// 标签生命周期状态
#[derive(Clone, Copy, PartialEq, Debug)]
#[repr(u8)]
pub enum TagState {
    New     = 0x00,   // 本周期新发现
    Updated = 0x01,   // 已存在，数据/RSSI 刷新
    Stale   = 0x02,   // 超过 stale_timeout 未更新
    Removed = 0x03,   // 超过 remove_timeout，待清除
}

/// 变长字段（最大 256 字节，静态分配，无堆）
pub struct VarField {
    pub len:  u16,          // 实际长度 0-256
    pub data: [u8; 256],    // 固定缓冲区
}

/// 统一标签记录
///
/// LF/HF:  field1 = ID,  field2 = User
/// UHF:    field1 = TID, field2 = EPC
pub struct TagRecord {
    // ── 元信息 ──
    pub reader_type:  ReaderType,
    pub reader_id:    u8,           // CAN 节点地址
    pub bus:          u8,           // 0=Bus1, 1=Bus2
    pub antenna:      u8,           // 天线号 1-8

    // ── 射频参数 ──
    pub rssi:         i16,          // dBm × 10
    pub phase_start:  u16,          // UHF: 0-3600 (×10°); LF/HF: 0xFFFF
    pub phase_end:    u16,          // UHF: 0-3600 (×10°); LF/HF: 0xFFFF

    // ── 时间与计数 ──
    pub read_count:   u16,          // 去重后累计读取次数
    pub first_seen:   u32,          // 首次发现（ms since boot）
    pub last_seen:    u32,          // 最后更新（ms since boot）
    pub state:        TagState,

    // ── 标签数据（变长） ──
    pub field1:       VarField,     // 主标识: ID (LF/HF) 或 TID (UHF)
    pub field2:       VarField,     // 扩展:  User (LF/HF) 或 EPC (UHF)
}

// sizeof(TagRecord) ≈ 534 字节
```

### 5.2 读写器状态

```rust
pub struct ReaderState {
    pub id:               u8,           // CAN 节点地址
    pub bus:              u8,           // 0=Bus1, 1=Bus2
    pub reader_type:      ReaderType,
    pub online:           bool,
    pub last_heartbeat:   u32,          // ms since boot
    pub temperature:      i8,           // ℃
    pub antenna_mask:     u8,           // 配置的天线掩码
    pub antenna_status:   u8,           // 实际天线连接状态
    pub error_count:      u16,
    pub alarm_code:       u8,           // 最近告警码
    pub inventory_active: bool,
    pub tag_count:        u16,          // 名下在场标签数
    pub fw_version:       [u8; 4],      // 固件版本
    pub session_counter:  u8,           // 命令 Session ID 计数器
}
```

### 5.3 标签去重策略

| 读写器类型 | 去重主键 | 理由 |
|-----------|---------|------|
| LF | `ReaderType::LF` + Field1(ID) 全部内容 | ID 是 LF 标签唯一标识 |
| HF | `ReaderType::HF` + Field1(ID) 全部内容 | UID 是 HF 标签唯一标识 |
| UHF | `ReaderType::UHF` + Field1(TID) 全部内容 | TID 全球唯一（EPC 可被改写，不可靠） |

去重使用 **FNV-1a 哈希**：

```rust
fn tag_hash(reader_type: ReaderType, field1: &VarField) -> u32 {
    let mut h: u32 = 0x811c_9dc5;  // FNV offset basis
    h ^= reader_type as u32;
    h = h.wrapping_mul(0x0100_0193);
    for i in 0..field1.len as usize {
        h ^= field1.data[i] as u32;
        h = h.wrapping_mul(0x0100_0193);
    }
    h
}
```

碰撞处理：哈希桶 + 链表（静态索引数组），碰撞时逐字节比对 Field1。

### 5.4 消息路由

```rust
/// 网关内部统一消息
pub enum GatewayMsg {
    // ── 下行（上位机 → CAN FD → 读写器）──
    StartInventory  { reader_index: u8 },
    StopInventory   { reader_index: u8 },
    SetReaderConfig { reader_index: u8, config: ReaderConfig },
    ReadBlock       { reader_index: u8, params: ReadBlockParams },
    WriteBlock      { reader_index: u8, params: WriteBlockParams },
    ResetReader     { reader_index: u8, mode: u8 },

    // ── 上行（读写器 → CAN FD → 网关 → Modbus）──
    TagReport       { reader_id: u8, bus: u8, tags: &'static [TagTlv] },
    TagEvent        { reader_id: u8, bus: u8, event_type: u8, tag: TagTlv },
    Heartbeat       { reader_id: u8, bus: u8, status: HeartbeatData },
    Alarm           { reader_id: u8, bus: u8, code: u8, detail: [u8; 4] },
    CmdResponse     { reader_id: u8, session_id: u8, status: u8,
                      data: heapless::Vec<u8, 512> },
}
```

---

## 6. 健壮性与容错设计

### 6.1 心跳与在线管理

| 参数 | 默认值 | 可配置 | 说明 |
|------|--------|--------|------|
| 心跳间隔 | 1000 ms | 是 | 读写器周期发送 |
| 离线判定 | 3 × 心跳间隔 | — | 连续 3 次未收到心跳 → 离线 |
| 重连检测 | — | — | 收到心跳 → 自动恢复在线 |

```
读写器                           网关
  │─── HEARTBEAT ──→ [t=0]        │  记录时间戳
  │                                │
  │─── HEARTBEAT ──→ [t=1s]       │  刷新时间戳
  │                                │
  │    (读写器断线)                │
  │                                │  [t=2s] 未收到心跳
  │                                │  [t=3s] 未收到心跳
  │                                │  [t=4s] 判定离线 → 上报 SCADA
  │                                │         标记该读写器名下标签为 Stale
  │                                │
  │─── HEARTBEAT ──→ [t=10s]      │  重新标记在线 → 上报 SCADA
```

### 6.2 命令超时与重传

| 参数 | 值 | 说明 |
|------|------|------|
| 命令超时 | 200 ms | 发送 CMD_REQ 后等待 CMD_RSP 的最长时间 |
| 最大重传次数 | 3 | 超时后重传，保持 SeqID 和 Session ID 不变 |
| 重传间隔 | 200 ms × 2^N | 指数退避（200ms, 400ms, 800ms） |
| 重传失败后处理 | 标记读写器通信异常，累加 error_count，上报上位机 | |

Session ID 机制防止读写器重复执行：
- 每条命令携带唯一 `SeqID`
- 读写器记录最近执行的 `SeqID`，若收到重复 SeqID 的命令，直接重发缓存的响应，不重复执行

### 6.3 拥塞控制

多台 UHF 读写器同时盘点时，CAN 总线负载可能接近上限。

**策略层级：**

| 级别 | 触发条件 | 措施 |
|------|---------|------|
| 正常 | 总线负载 < 70% | 无限制 |
| 预警 | 总线负载 70%-85% | 网关下发降频指令，增大上报间隔 |
| 拥塞 | 总线负载 > 85% | 读写器丢弃低 RSSI 标签数据，仅上报强信号标签 |
| Error Passive | CAN 控制器进入 Error Passive | 读写器暂停上报，等待恢复后续传 |

总线负载率计算：

```
load = (实际传输 bit 数 / 理论最大 bit 数) × 1000 ‰
     = (sum_of_frame_bits_per_second / 2_000_000) × 1000
```

### 6.4 异常处理矩阵

| 异常 | 读写器策略 | 网关策略 |
|------|-----------|---------|
| 心跳超时 | 自检 CAN 模块，自动复位 | 标记离线，上报 SCADA，尝试发 RESET 命令 |
| 应用层 CRC 失败 | 丢弃帧，不回复 | 丢弃帧，按超时重传处理 |
| 连续 CRC 失败 ≥5 次 | 发送 ALARM | 记录日志，上报 SCADA，检查物理线路 |
| 接收缓冲溢出 | 发送 Flow Control (Wait) | 暂停发送，等待 Ready |
| RF 过温 | 自动停止 RF，发送 ALARM | 记录事件，暂停分配盘点任务 |
| 天线断开 | 发送 ALARM（含天线编号） | 更新天线状态，上报 SCADA |
| ACK 超时 | 无操作（被动方） | 重传命令（最多 3 次），然后报错 |
| 多帧重组超时 | 丢弃不完整数据 | 丢弃不完整数据，释放重组缓冲 |
| 多帧序号不连续 | 发送 Flow Control (Abort) | 丢弃并释放缓冲 |
| 标签存储满 | — | 按 LRU 淘汰最久未更新标签，置 TAG_OVERFLOW 标志 |
| CAN Bus Off | 自动恢复（硬件重初始化） | 检测并上报，等待恢复 |

### 6.5 看门狗策略

| 看门狗 | 用途 | 超时 |
|--------|------|------|
| RTWDOG | 系统级看门狗 | 5 秒 |
| 任务级喂狗 | 每个功能模块设独立喂狗标记 | — |

```
主循环每 1s 检查:
  CAN1 任务是否活跃 → 标记
  CAN2 任务是否活跃 → 标记
  Modbus TCP 是否活跃 → 标记
  Modbus RTU 是否活跃 → 标记
  标签引擎是否活跃 → 标记

仅当 所有标记 均正常时才喂 RTWDOG
任一模块卡死 → RTWDOG 超时 → 硬件复位
```

---

## 7. 性能指标与内存预算

### 7.1 带宽估算

**CAN FD（单总线，2 Mbps 数据段）：**

| 指标 | 值 | 计算依据 |
|------|------|---------|
| 单帧传输时间 | ~0.4 ms | 仲裁段 ~140bit/500k + 数据段 512bit/2M |
| 最大帧率 | ~2500 帧/秒 | 1000ms / 0.4ms |
| 有效吞吐 | ~160 KB/s | 2500 × 64B |
| UHF 典型标签（34B TLV，单帧） | ~2500 标签/秒 | 每帧 1 标签 |
| LF 短标签（15B TLV，3 标签/帧） | ~7500 标签/秒 | 每帧 3 标签 |
| **双总线合计** | **~5000-15000 标签/秒** | 取决于标签数据大小 |

**Modbus TCP（100 Mbps 以太网）：**

| 指标 | 值 |
|------|------|
| 单次 FC04 最大 | 125 寄存器 = 250 字节 |
| 标签摘要扫描 256 个 | ~22 次请求 × ~1ms = ~22ms |
| 邮箱全量读（534B 标签） | 3 次请求 × ~1ms = ~3ms |
| 远超 CAN 下行速率 | **不是系统瓶颈** |

**Modbus RTU（115200 baud）：**

| 指标 | 值 |
|------|------|
| 有效带宽 | ~11.5 KB/s |
| 单次 FC04 (125 寄存器) | ~25ms |
| 标签摘要扫描 256 个 | ~22 × 25ms = ~550ms |
| 适用场景 | 低速监控、触摸屏面板 |

### 7.2 CPU 负载估算（RT1062 @ 600 MHz）

| 任务 | 估算 CPU 占用 |
|------|---------------|
| CAN FD 中断 + 解码（双总线 5000 帧/秒） | ~5% |
| ISO-TP 多帧重组 | ~2% |
| 标签去重、哈希查找、聚合 | ~3% |
| CRC16 计算（软件） | ~1% |
| Modbus TCP 处理（smoltcp + 应用层） | ~2% |
| Modbus RTU 处理（DMA + 帧解析） | ~1% |
| 设备管理、心跳监测 | <1% |
| **总计** | **~15%** |

600 MHz Cortex-M7 处理能力充裕，留有大量余量用于未来扩展。

### 7.3 内存预算

| 组件 | 大小 | 说明 |
|------|------|------|
| 标签池 ×256 | 256 × 534B = **~136 KB** | 最多 256 标签同时在场 |
| 哈希索引表 | 512 × 2B = 1 KB | 256 标签 × 2 倍桶数 |
| 读写器状态 ×60 | 60 × 48B = ~3 KB | 双总线各 30 个 |
| CAN 收发 FIFO ×2 | 2 × 64帧 × 72B = ~9 KB | 每帧 64B 数据 + 8B 元信息 |
| ISO-TP 重组缓冲 ×4 | 4 × 600B = ~2.4 KB | 4 路并发重组 |
| Modbus TCP 缓冲 | ~4 KB | 收发各 2 KB |
| Modbus RTU 缓冲 | ~1 KB | 单帧最大 256 字节 |
| smoltcp 网络栈 | ~16 KB | TCP/IP 缓冲 |
| 栈空间 | ~16 KB | 中断栈 + 主栈 |
| **合计** | **~189 KB** | |
| **RT1062 可用** | **1024 KB** | |
| **占用率** | **~18%** | 余量充足 |

---

## 8. 扩展性设计

### 8.1 协议版本管理

应用层 PDU 预留版本协商机制。未来版本升级时，通过 GET_INFO 响应中的协议版本字段实现向前兼容。

### 8.2 读写器类型扩展

| 预留 ReaderType | 可能用途 |
|----------------|---------|
| 0x04 | UWB 定位标签 |
| 0x05 | 有源 RFID (2.4 GHz) |
| 0x06-0x0F | 未来预留 |

新增类型只需定义 Field1/Field2 语义和专用 FuncCode 区间，核心架构（TLV 编码、多帧传输、邮箱机制）无需修改。

### 8.3 功能码扩展空间

| FuncCode 范围 | 分配 |
|--------------|------|
| 0x01-0x0F | 系统通用命令 |
| 0x10-0x1F | UHF 专用 |
| 0x20-0x2F | HF 专用 |
| 0x30-0x3F | LF 专用 |
| 0x40-0x7F | **预留（未来新读写器类型或复合命令）** |
| 0x80-0xEF | **用户自定义（项目特定扩展）** |
| 0xF0-0xFF | OTA / 诊断 |

### 8.4 Modbus 寄存器扩展

| 地址范围 | 当前用途 | 扩展空间 |
|---------|---------|---------|
| 0x0000-0x00FF | 网关全局 | 充足（当前仅用 16 个） |
| 0x0100-0x1FFF | 读写器（60×128） | 可通过减小步进支持更多读写器 |
| 0x2000-0x2FFF | 标签邮箱 | 可增加多邮箱窗口并发访问 |
| 0x3000-0x3FFF | 标签摘要 | 当前 256 标签，可扩至 409 标签 |
| 0x4000-0xFFFF | **完全空闲** | 未来扩展（日志、统计、诊断等） |

### 8.5 多网关级联

预留 Modbus TCP 网关间通信能力。多台网关可通过以太网交换机组网，上位机统一管理多个 Modbus TCP Server。每台网关分配独立从站地址。

---

## 9. 附录

### 9.1 字节序约定

| 总线 | 字节序 |
|------|--------|
| CAN FD 应用层 | **Little Endian**（低字节在前） |
| Modbus TCP/RTU | **Big Endian**（高字节在前，Modbus 标准） |

网关负责在 CAN FD 与 Modbus 之间自动进行字节序转换。

### 9.2 数据类型定义

| 类型 | 宽度 | 说明 |
|------|------|------|
| uint8 | 1 字节 | 无符号 8 位 |
| int8 | 1 字节 | 有符号 8 位 |
| uint16 | 2 字节 | 无符号 16 位 |
| int16 | 2 字节 | 有符号 16 位 |
| uint32 | 4 字节 | 无符号 32 位 |

### 9.3 CRC16-Modbus 参考实现

```rust
pub fn crc16_modbus(data: &[u8]) -> u16 {
    let mut crc: u16 = 0xFFFF;
    for &byte in data {
        crc ^= byte as u16;
        for _ in 0..8 {
            if crc & 0x0001 != 0 {
                crc = (crc >> 1) ^ 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    crc
}
```

### 9.4 CAN ID 编解码参考实现

```rust
#[derive(Clone, Copy, Debug)]
pub struct CanFdId {
    pub priority:  u8,   // 3 bit
    pub msg_type:  u8,   // 5 bit
    pub func_code: u8,   // 8 bit
    pub dest_id:   u8,   // 5 bit
    pub source_id: u8,   // 8 bit
}

impl CanFdId {
    pub fn encode(&self) -> u32 {
        ((self.priority  as u32 & 0x07) << 26)
      | ((self.msg_type  as u32 & 0x1F) << 21)
      | ((self.func_code as u32 & 0xFF) << 13)
      | ((self.dest_id   as u32 & 0x1F) <<  8)
      |  (self.source_id as u32 & 0xFF)
    }

    pub fn decode(id: u32) -> Self {
        Self {
            priority:  ((id >> 26) & 0x07) as u8,
            msg_type:  ((id >> 21) & 0x1F) as u8,
            func_code: ((id >> 13) & 0xFF) as u8,
            dest_id:   ((id >>  8) & 0x1F) as u8,
            source_id: ( id        & 0xFF) as u8,
        }
    }
}
```

### 9.5 TLV 编解码参考实现

```rust
pub struct TagTlv {
    pub tag_type:    ReaderType,
    pub antenna:     u8,
    pub rssi:        i16,
    pub phase_start: u16,
    pub phase_end:   u16,
    pub field1:      VarField,
    pub field2:      VarField,
}

impl TagTlv {
    /// 编码为字节流，返回实际写入长度
    pub fn encode(&self, buf: &mut [u8]) -> usize {
        let mut pos = 0;
        buf[pos] = self.tag_type as u8;                       pos += 1;
        buf[pos] = self.antenna;                               pos += 1;
        buf[pos..pos+2].copy_from_slice(&self.rssi.to_le_bytes());         pos += 2;
        buf[pos..pos+2].copy_from_slice(&self.phase_start.to_le_bytes());  pos += 2;
        buf[pos..pos+2].copy_from_slice(&self.phase_end.to_le_bytes());    pos += 2;
        buf[pos..pos+2].copy_from_slice(&self.field1.len.to_le_bytes());   pos += 2;
        let n1 = self.field1.len as usize;
        buf[pos..pos+n1].copy_from_slice(&self.field1.data[..n1]);         pos += n1;
        buf[pos..pos+2].copy_from_slice(&self.field2.len.to_le_bytes());   pos += 2;
        let n2 = self.field2.len as usize;
        buf[pos..pos+n2].copy_from_slice(&self.field2.data[..n2]);         pos += n2;
        pos
    }

    /// 从字节流解码
    pub fn decode(buf: &[u8]) -> Option<(Self, usize)> {
        if buf.len() < 10 { return None; }
        let mut pos = 0;
        let tag_type = match buf[pos] {
            0x01 => ReaderType::LF,
            0x02 => ReaderType::HF,
            0x03 => ReaderType::UHF,
            _    => return None,
        };
        pos += 1;
        let antenna = buf[pos];                                             pos += 1;
        let rssi = i16::from_le_bytes([buf[pos], buf[pos+1]]);             pos += 2;
        let phase_start = u16::from_le_bytes([buf[pos], buf[pos+1]]);      pos += 2;
        let phase_end = u16::from_le_bytes([buf[pos], buf[pos+1]]);        pos += 2;
        let f1_len = u16::from_le_bytes([buf[pos], buf[pos+1]]);           pos += 2;
        if f1_len > 256 || pos + f1_len as usize + 2 > buf.len() { return None; }
        let mut field1 = VarField { len: f1_len, data: [0u8; 256] };
        field1.data[..f1_len as usize].copy_from_slice(&buf[pos..pos+f1_len as usize]);
        pos += f1_len as usize;
        let f2_len = u16::from_le_bytes([buf[pos], buf[pos+1]]);           pos += 2;
        if f2_len > 256 || pos + f2_len as usize > buf.len() { return None; }
        let mut field2 = VarField { len: f2_len, data: [0u8; 256] };
        field2.data[..f2_len as usize].copy_from_slice(&buf[pos..pos+f2_len as usize]);
        pos += f2_len as usize;
        Some((Self { tag_type, antenna, rssi, phase_start, phase_end, field1, field2 }, pos))
    }
}
```

---

> **文档结束**
> 数据格式: Little Endian (CAN FD) / Big Endian (Modbus)
> CRC: CRC16-Modbus (poly=0x8005, init=0xFFFF)
> 所有字段变长，最大 256 字节/字段
> 最大标签数据: 522 字节/标签 (TLV 编码)
