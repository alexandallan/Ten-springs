# MIMXRT1060 工业网关 — Rust 实施指南

> 本文档基于《工业网关通讯数据架构.md》，详细规划从零到部署的每一步。
> 平台：NXP MIMXRT1060-EVK (MIMXRT1062DVL6A)
> 语言：Rust (`#![no_std]`, `#![no_main]`)

---

## 目录

1. [开源库全景分析](#1-开源库全景分析)
2. [功能块实现可行性评估](#2-功能块实现可行性评估)
3. [项目结构](#3-项目结构)
4. [依赖清单](#4-依赖清单)
5. [阶段 0：项目骨架与 RTIC 基础](#5-阶段-0项目骨架与-rtic-基础)
6. [阶段 1：FlexCAN3 原生 CAN FD 驱动](#6-阶段-1flexcan3-原生-can-fd-驱动)
7. [阶段 2：SPI + MCP2518FD 第二路 CAN FD](#7-阶段-2spi--mcp2518fd-第二路-can-fd)
8. [阶段 3：CAN FD 协议栈](#8-阶段-3can-fd-协议栈)
9. [阶段 4：以太网 ENET 驱动](#9-阶段-4以太网-enet-驱动)
10. [阶段 5：Modbus TCP Server](#10-阶段-5modbus-tcp-server)
11. [阶段 6：Modbus RTU (RS485)](#11-阶段-6modbus-rtu-rs485)
12. [阶段 7：网关核心逻辑](#12-阶段-7网关核心逻辑)
13. [阶段 8：集成测试与调优](#13-阶段-8集成测试与调优)
14. [依赖关系与关键路径](#14-依赖关系与关键路径)
15. [风险分析与应对](#15-风险分析与应对)

---

## 1. 开源库全景分析

### 1.1 imxrt-hal v0.5 已有驱动清单

| 模块 | 外设 | DMA 支持 | embedded-hal trait | 成熟度 |
|------|------|---------|-------------------|--------|
| `imxrt_hal::lpspi` | LPSPI 1-4 | 有（dma_write / dma_read / dma_full_duplex） | Write/Transfer (eh 0.2 + 1.0) | 生产级 |
| `imxrt_hal::lpuart` | LPUART 1-8 | 有（dma_write / dma_read） | Read/Write (eh 1.0), embedded-io | 生产级 |
| `imxrt_hal::gpio` | GPIO1-5 | 无 | — | 生产级 |
| `imxrt_hal::gpt` | GPT1, GPT2 | 无 | — | 生产级 |
| `imxrt_hal::pit` | PIT 4 通道 | 无 | — | 生产级 |
| `imxrt_hal::dma` | eDMA 32 通道 | 核心模块 | futures-based async | 生产级 |
| `imxrt_hal::ccm` | 时钟控制 | — | — | 生产级 |
| `imxrt_hal::iomuxc` | 引脚复用 | — | — | 生产级 |
| `imxrt_hal::adc` | ADC1, ADC2 | 无 | — | 可用 |
| `imxrt_hal::flexpwm` | FlexPWM 1-4 | 无 | — | 可用 |
| `imxrt_hal::tempmon` | 温度监测 | — | — | 可用 |
| `imxrt_hal::trng` | 真随机数 | — | — | 可用 |
| `imxrt_hal::snvs` | 安全 NV 存储 | — | — | 可用 |
| `imxrt_hal::dcdc` | DC-DC 转换器 | — | — | 可用 |
| `imxrt_hal::timer` | 定时器抽象 | — | — | 可用 |

### 1.2 imxrt-hal v0.5 缺失驱动

| 外设 | imxrt-ral 寄存器定义 | HAL 驱动 | 上游状态 |
|------|---------------------|---------|---------|
| **FlexCAN (CAN 2.0)** | `ral::can` — CAN1/CAN2 实例 | 无 | PR #171 draft（2024-08，硬件已测，未合入） |
| **FlexCAN3 (CAN FD)** | `ral::can3` — 含 FD 时序/补偿寄存器 | 无 | 同上 |
| **ENET (以太网)** | `ral::enet` — ENET1/ENET2 完整寄存器 | 无 | PR #146 draft（2023-11，smoltcp 示例但 build 已坏） |
| FlexSPI | `ral::flexspi` | 无 | — |
| SEMC | `ral::semc` | 无 | — |
| uSDHC | `ral::usdhc` | 无 | — |
| SAI | `ral::sai` | 部分（chip 内部驱动） | — |
| FlexIO | `ral::flexio` | 无 | — |

### 1.3 第三方开源库评估

#### 1.3.1 并发框架：RTIC v2

| 项目 | 值 |
|------|------|
| crate | `rtic` 2.2.0 |
| no_std | 是 |
| Cortex-M7 支持 | 是（`thumbv7-backend` feature，BASEPRI 优先级调度） |
| imxrt 支持 | `rtic-monotonics` 2.1.0 内置 `imxrt_gpt1` / `imxrt_gpt2` 单调定时器 |
| 成熟度 | 生产级（228K 下载） |
| 参考项目 | `teensy4-rs` 多个 RTIC 示例（UART/SPI/GPT/PIT） |
| 关键特性 | 编译期死锁检测、零开销抢占、硬件中断任务 + 软件 async 任务、共享资源 `.lock()` |

**RTIC v2 在 imxrt 上的使用模式**：

```rust
#[rtic::app(device = imxrt_ral, peripherals = false, dispatchers = [KPP, GPIO6_7_8_9])]
mod app {
    use rtic_monotonics::imxrt::prelude::*;
    imxrt_gpt1_monotonic!(Mono);

    #[shared]
    struct Shared { /* 跨任务共享资源 */ }

    #[local]
    struct Local { /* 任务私有资源 */ }

    #[init]
    fn init(cx: init::Context) -> (Shared, Local) { /* 硬件初始化 */ }

    #[task(binds = CAN3, priority = 4, shared = [tag_store])]
    fn can_fd_rx(cx: can_fd_rx::Context) { /* CAN FD 接收中断 */ }

    #[task(binds = LPUART3, priority = 3, shared = [modbus_ctx])]
    fn modbus_rtu_rx(cx: modbus_rtu_rx::Context) { /* RS485 接收中断 */ }

    #[task(binds = ENET, priority = 3, shared = [eth_device])]
    fn ethernet_irq(cx: ethernet_irq::Context) { /* 以太网中断 */ }

    #[task(priority = 2, shared = [tag_store, reader_states])]
    async fn gateway_tick(cx: gateway_tick::Context) {
        loop {
            Mono::delay(50.millis()).await;  // 50ms 周期
            // 处理标签引擎、设备管理、Modbus TCP 轮询
        }
    }

    #[task(priority = 1, shared = [reader_states])]
    async fn heartbeat_check(cx: heartbeat_check::Context) {
        loop {
            Mono::delay(1000.millis()).await;
            // 检查心跳超时、闪烁 LED
        }
    }
}
```

**RTIC 中断名映射**（来自 `imxrt-ral` 的 `Interrupt` 枚举）：

| 中断名 | 用途 |
|--------|------|
| `CAN1` | FlexCAN1 中断 |
| `CAN2` | FlexCAN2 中断 |
| `CAN3` | FlexCAN3 (CAN FD) 中断 |
| `LPUART1` ~ `LPUART8` | 串口中断 |
| `LPSPI1` ~ `LPSPI4` | SPI 中断 |
| `ENET` | 以太网 MAC 中断 |
| `GPT1` | 通用定时器 1（RTIC Mono 占用） |
| `GPT2` | 通用定时器 2 |
| `PIT` | 周期中断定时器 |
| `DMA0_DMA16` ~ `DMA15_DMA31` | DMA 通道中断（成对） |
| `KPP` | 键盘口（空闲，可做 RTIC dispatcher） |
| `GPIO6_7_8_9` | 高速 GPIO（空闲，可做 RTIC dispatcher） |

**优先级规划**（RTIC 数值越大优先级越高）：

| RTIC 优先级 | 任务 | 说明 |
|------------|------|------|
| 4 | CAN FD RX（双总线） | 最高：不丢帧 |
| 3 | ENET IRQ / LPUART RX | 网络和串口中断 |
| 2 | gateway_tick (50ms) | 消息路由、标签引擎、Modbus 轮询 |
| 1 | heartbeat_check (1s) | 心跳检查、看门狗喂狗、LED |

#### 1.3.2 CAN FD 驱动：MCP2518FD

**方案 A（推荐）：`mcp2518fd` GitHub 仓库**

| 项目 | 值 |
|------|------|
| 仓库 | https://github.com/adom-inc/mcp2518fd |
| 版本 | 0.1.0（未发布到 crates.io） |
| no_std | 是 |
| embedded-hal | v1.0.0 |
| embedded-can | 0.4.1 |
| 成熟度 | Alpha |
| 已知限制 | 无 TX abort、无 FIFO reset、无便捷位定时配置；可通过 raw 寄存器访问弥补 |
| 阻塞/异步 | 同时支持 blocking 和 async（`embedded-hal-async`） |

**使用方式**：

```toml
mcp2518fd = { git = "https://github.com/adom-inc/mcp2518fd" }
```

```rust
use mcp2518fd::MCP2518FD;
use imxrt_hal::lpspi::Lpspi;

let spi = /* LPSPI2 实例 */;
let cs = /* GPIO CS 引脚 */;
let mut can_fd = MCP2518FD::new(spi, cs);
can_fd.configure(/* 500k/2M 位定时 */)?;
can_fd.send(frame)?;
let rx = can_fd.receive()?;
```

**方案 B（备选）：`mcp2517` crates.io**

| 项目 | 值 |
|------|------|
| crate | `mcp2517` 0.2.0 |
| no_std | 是 |
| embedded-hal | v1.0.0 |
| 成熟度 | 早期（1,894 下载） |
| 说明 | MCP2517FD 和 MCP2518FD 寄存器兼容 |

#### 1.3.3 ISO-TP 多帧传输

**方案 A：`can-iso-tp` crate**

| 项目 | 值 |
|------|------|
| crate | `can-iso-tp` 0.1.0 |
| no_std | 是（`no_alloc` 模式使用 `&mut [u8]` 缓冲） |
| 成熟度 | 极早期（15 下载，2026-02 发布） |
| 依赖 | `embedded-can-interface` 0.1.1 |
| 已知风险 | 极新，可能有 breaking change |

**方案 B（推荐）：自实现**

ISO-TP 协议简单（3 种帧类型 + 流控），且我们的场景需要适配 CAN FD 64 字节载荷（标准 ISO-TP 针对 CAN 2.0 的 8 字节）。自实现约 200-300 行代码，可完全贴合架构文档定义。

```rust
/// ISO-TP 重组状态机
pub struct IsoTpReassembler {
    buf: [u8; 600],          // 最大标签数据 522B + 余量
    total_len: u16,
    received: u16,
    packet_id: u16,
    source_id: u8,
    next_seq: u8,
    active: bool,
    timestamp: u32,          // 超时检测
}

/// 4 路并发重组器
pub struct IsoTpEngine {
    slots: [IsoTpReassembler; 4],
}
```

#### 1.3.4 以太网 ENET 驱动

**主要参考：`rt1062-eth-rs`**

| 项目 | 值 |
|------|------|
| 仓库 | https://github.com/Timvrakas/rt1062-eth-rs |
| crate 名 | `imxrt-eth` |
| 目标芯片 | RT1062（与 RT1060 同硅） |
| smoltcp 版本 | 0.10.0（需升级至 0.12） |
| PHY | DP83825I（Teensy 4.1）→ 需适配 KSZ8081（EVK） |
| 架构 | `src/lib.rs`（ENET 驱动 + smoltcp Device）+ `src/ring.rs`（DMA 描述符环） |

**核心实现结构**：

```rust
// DMA 描述符环
pub struct RxRing<const N: usize> {
    descriptors: [RxDescriptor; N],
    buffers: [[u8; 1536]; N],
    index: usize,
}

pub struct TxRing<const N: usize> {
    descriptors: [TxDescriptor; N],
    buffers: [[u8; 1536]; N],
    index: usize,
}

// ENET 驱动
pub struct EnetDevice {
    enet: ral::enet::ENET,
    rx_ring: RxRing<12>,
    tx_ring: TxRing<12>,
}

// 实现 smoltcp Device trait
impl smoltcp::phy::Device for EnetDevice {
    type RxToken<'a> = EnetRxToken<'a>;
    type TxToken<'a> = EnetTxToken<'a>;

    fn receive(&mut self, _ts: Instant) -> Option<(Self::RxToken<'_>, Self::TxToken<'_>)> {
        // 检查 RX 描述符，若有就绪帧则返回 token 对
    }

    fn transmit(&mut self, _ts: Instant) -> Option<Self::TxToken<'_>> {
        // 检查 TX 描述符，若有空闲则返回 token
    }

    fn capabilities(&self) -> DeviceCapabilities {
        let mut caps = DeviceCapabilities::default();
        caps.medium = Medium::Ethernet;
        caps.max_transmission_unit = 1514;
        caps
    }
}
```

**EVK 适配要点**：

| 对比项 | Teensy 4.1 (rt1062-eth-rs) | MIMXRT1060-EVK |
|--------|---------------------------|----------------|
| PHY 芯片 | DP83825I | **KSZ8081RNB** |
| PHY 地址 | 0x00 | **0x02**（原理图确认） |
| RMII REF_CLK | 外部 50 MHz 晶振 | **ENET_REF_CLK 引脚输出**（需 PLL 配置） |
| 引脚映射 | Teensy pad 定义 | **EVK IOMUXC 映射**（见下表） |
| 复位引脚 | GPIO | **GPIO_AD_B0_09**（注意：与 LED 共用组别，需确认） |

**EVK ENET RMII 引脚映射**：

| 信号 | 引脚 | IOMUXC ALT | 说明 |
|------|------|-----------|------|
| ENET_MDC | GPIO_EMC_40 | ALT4 | PHY 管理时钟 |
| ENET_MDIO | GPIO_EMC_41 | ALT4 | PHY 管理数据 |
| ENET_RXD0 | GPIO_B1_04 | ALT3 | 接收数据 0 |
| ENET_RXD1 | GPIO_B1_05 | ALT3 | 接收数据 1 |
| ENET_CRS_DV | GPIO_B1_06 | ALT3 | 载波检测 |
| ENET_TXD0 | GPIO_B1_07 | ALT3 | 发送数据 0 |
| ENET_TXD1 | GPIO_B1_08 | ALT3 | 发送数据 1 |
| ENET_TXEN | GPIO_B1_09 | ALT3 | 发送使能 |
| ENET_TX_CLK | GPIO_B1_10 | ALT6 | 50 MHz 参考时钟 |
| ENET_RX_ER | GPIO_B1_11 | ALT3 | 接收错误 |

**KSZ8081 PHY 初始化序列**（MDIO 寄存器操作）：

```rust
fn init_ksz8081(enet: &mut EnetDevice) {
    // 1. 软复位 PHY
    enet.mdio_write(PHY_ADDR, 0x00, 0x8000);  // BCR.Reset = 1
    delay_ms(10);

    // 2. 等待复位完成
    while enet.mdio_read(PHY_ADDR, 0x00) & 0x8000 != 0 {}

    // 3. 使能自协商
    enet.mdio_write(PHY_ADDR, 0x00, 0x1200);  // AN Enable + Restart AN

    // 4. 等待链路建立
    let timeout = 5000; // ms
    let start = now_ms();
    loop {
        let bsr = enet.mdio_read(PHY_ADDR, 0x01);
        if bsr & 0x0004 != 0 { break; }  // Link Up
        if now_ms() - start > timeout { panic!("PHY link timeout"); }
        delay_ms(100);
    }

    // 5. 读取链路状态
    let ctrl2 = enet.mdio_read(PHY_ADDR, 0x1F);  // PHY Control 2
    let speed_100 = (ctrl2 >> 2) & 0x07;  // Speed indication
    defmt::info!("PHY link up, mode: {}", speed_100);
}
```

**DCache 一致性处理**：

RT1062 Cortex-M7 具有 32KB DCache。ENET DMA 直接访问内存，必须处理缓存一致性：

```rust
// 方案 A：MPU 配置非缓存区域（推荐）
// 在 init() 中将 DMA 描述符和缓冲区所在内存区域设为 Device 或 Non-cacheable
use cortex_m::peripheral::MPU;

fn configure_mpu_for_dma(mpu: &mut MPU) {
    // 假设 DMA 缓冲区放在 OCRAM2 (0x20200000) 的特定区段
    unsafe {
        mpu.rnr.write(0);  // Region 0
        mpu.rbar.write(DMA_BUF_BASE & 0xFFFF_FFE0);
        mpu.rasr.write(
            (0b000 << 24) |  // TEX=0, C=0, B=0 → Strongly Ordered / Non-cacheable
            (0b011 << 1)  |  // Size = 2^(3+1) = 16 字节起步，按需调整
            1                 // Enable
        );
    }
}

// 方案 B：手动刷缓存（备选）
use cortex_m::asm;
cortex_m::peripheral::SCB::clean_dcache_by_address(buf_addr, buf_len);   // TX 前
cortex_m::peripheral::SCB::invalidate_dcache_by_address(buf_addr, buf_len); // RX 后
```

#### 1.3.5 TCP/IP 协议栈：smoltcp

| 项目 | 值 |
|------|------|
| crate | `smoltcp` 0.12.0 |
| no_std | 是（关闭 `std` feature） |
| 成熟度 | 生产级（5M+ 下载） |
| 所需 feature | `medium-ethernet`, `proto-ipv4`, `socket-tcp`, `socket-dhcpv4` |

**smoltcp 在网关中的使用模式**：

```rust
use smoltcp::iface::{Config, Interface, SocketSet};
use smoltcp::socket::tcp;
use smoltcp::wire::{EthernetAddress, IpCidr, Ipv4Address};
use smoltcp::time::Instant;

// 初始化
let mac = EthernetAddress([0x02, 0x00, 0x00, 0x00, 0x00, 0x01]);
let config = Config::new(mac.into());
let mut iface = Interface::new(config, &mut enet_device, Instant::ZERO);
iface.update_ip_addrs(|addrs| {
    addrs.push(IpCidr::new(Ipv4Address::new(192, 168, 1, 100).into(), 24)).unwrap();
});

let mut sockets = SocketSet::new(&mut socket_storage[..]);
let tcp_handle = sockets.add(tcp::Socket::new(
    tcp::SocketBuffer::new(&mut tcp_rx_buf[..]),
    tcp::SocketBuffer::new(&mut tcp_tx_buf[..]),
));

// 主循环中调用
fn poll_network(iface: &mut Interface, device: &mut EnetDevice, sockets: &mut SocketSet) {
    let now = Instant::from_millis(system_tick_ms() as i64);
    iface.poll(now, device, sockets);
}
```

#### 1.3.6 Modbus：rmodbus

| 项目 | 值 |
|------|------|
| crate | `rmodbus` 0.12.2 |
| no_std | 是（feature = `heapless`） |
| 成熟度 | 生产级（150K 下载） |
| 支持协议 | TCP + RTU + ASCII |
| 集成 crate | `smoltcp-rmodbus` 0.1.0（smoltcp TCP 传输层） |
| 寄存器存储 | `ModbusContext` trait，可自定义存储大小 |

**rmodbus 架构**：

```
上位机 Modbus 请求
       │
       ▼
┌─── smoltcp TCP Socket ───┐    ┌─── LPUART DMA ──────┐
│  smoltcp-rmodbus 传输层   │    │  RTU 帧解析          │
└──────────┬───────────────┘    └──────────┬───────────┘
           │                               │
           ▼                               ▼
      ┌── rmodbus TCP 解码 ──┐   ┌── rmodbus RTU 解码 ──┐
      └──────────┬───────────┘   └──────────┬───────────┘
                 │                           │
                 ▼                           ▼
          ┌─────────────────────────────────────┐
          │         ModbusContext 寄存器存储      │
          │  Coils[320] + DI[320]               │
          │  + Input[16384] + Holding[16384]    │
          │                                     │
          │  （TCP 和 RTU 共享同一实例）         │
          └─────────────────────────────────────┘
```

**no_std 使用方式**：

```rust
use rmodbus::server::context::ModbusContext;
use rmodbus::server::ModbusFrame;

// 静态分配 Modbus 上下文
static mut CTX: ModbusContext = ModbusContext::new();

// 处理 TCP 请求
fn handle_modbus_tcp(request: &[u8], response: &mut heapless::Vec<u8, 256>) {
    let mut frame = ModbusFrame::new(1, request, ModbusProto::TcpUdp, response);
    if frame.parse().is_ok() {
        if frame.processing_required {
            let result = match frame.func {
                0x01 => frame.response_coils(unsafe { &CTX }),
                0x03 => frame.response_holding(unsafe { &CTX }),
                0x04 => frame.response_input(unsafe { &CTX }),
                0x05 => frame.set_coil(unsafe { &mut CTX }),
                0x06 => frame.set_holding(unsafe { &mut CTX }),
                0x10 => frame.set_holdings_from_frame(unsafe { &mut CTX }),
                _ => frame.error_illegal_function(),
            };
        }
        frame.finalize_response();
    }
}
```

#### 1.3.7 CRC16

| 项目 | 值 |
|------|------|
| crate | `crc` 3.4.0 |
| no_std | 是 |
| 成熟度 | 生产级（142M 下载） |
| 预置算法 | `CRC_16_MODBUS` 直接可用 |
| 内存模式 | `NoTable`（零 RAM）/ `Bytewise`（256 条目表）/ `Table<L>`（高吞吐） |

```rust
use crc::{Crc, CRC_16_MODBUS};

const MODBUS_CRC: Crc<u16> = Crc::<u16>::new(&CRC_16_MODBUS);

fn calc_crc(data: &[u8]) -> u16 {
    MODBUS_CRC.checksum(data)
}

fn verify_crc(data: &[u8], expected: u16) -> bool {
    MODBUS_CRC.checksum(data) == expected
}
```

> 注：`rmodbus` 内置了 Modbus RTU CRC 计算，无需额外引用。`crc` crate 用于 CAN FD 应用层 CRC。

#### 1.3.8 数据结构：heapless

| 项目 | 值 |
|------|------|
| crate | `heapless` 0.9.2 |
| no_std | 是（核心定位） |
| 成熟度 | 生产级（55M 下载） |

**本项目使用的关键类型**：

| 类型 | 用途 |
|------|------|
| `Vec<u8, 64>` | CAN FD 帧缓冲 |
| `Vec<u8, 600>` | ISO-TP 重组缓冲 |
| `Vec<u8, 256>` | Modbus 响应帧 |
| `spsc::Queue<CanFrame, 64>` | CAN 中断 → 主循环的无锁队列 |
| `IndexMap<u32, u16, 512>` | 标签哈希索引（hash → slot） |
| `String<32>` | 日志格式化 |

#### 1.3.9 embedded-can trait 现状

| 项目 | 值 |
|------|------|
| crate | `embedded-can` 0.4.1 |
| CAN 2.0 trait | 有（`Frame`, `StandardId`, `ExtendedId`） |
| **CAN FD trait** | **无** |

`embedded-can` 0.4.1 仅定义 CAN 2.0 帧 trait。生态中**没有标准化的 CAN FD trait**。

**应对策略**：自定义统一 CAN FD 接口 trait：

```rust
/// 统一 CAN FD 总线接口（FlexCAN3 和 MCP2518FD 各自实现）
pub trait CanFdBus {
    type Error: core::fmt::Debug;

    /// 发送 CAN FD 帧
    fn send(&mut self, id: u32, data: &[u8], brs: bool) -> Result<(), Self::Error>;

    /// 尝试接收（非阻塞）
    fn try_recv(&mut self) -> Result<Option<CanFdFrame>, Self::Error>;

    /// 设置接收过滤器
    fn set_filter(&mut self, index: u8, id: u32, mask: u32) -> Result<(), Self::Error>;

    /// 获取总线状态
    fn bus_state(&self) -> BusState;
}

pub struct CanFdFrame {
    pub id: u32,          // 29-bit 扩展 ID
    pub data: [u8; 64],   // 最大 64 字节
    pub len: u8,           // 实际数据长度
    pub brs: bool,         // Bit Rate Switch
    pub esi: bool,         // Error State Indicator
}

pub enum BusState {
    Active,
    ErrorPassive,
    BusOff,
}
```

---

## 2. 功能块实现可行性评估

| 功能块 | 方案 | 复杂度 | 预估工时 | 风险 |
|--------|------|--------|---------|------|
| RTIC 骨架 + defmt | 直接使用成熟库 | 低 | 1-2 天 | 低 |
| FlexCAN3 CAN FD | RAL 寄存器级自研 | **高** | 3-5 天 | **高** |
| MCP2518FD Bus2 | 第三方 Alpha 库 + HAL SPI | 中 | 2-3 天 | 中-高 |
| ISO-TP | 自实现（~300 行） | 中 | 1-2 天 | 低 |
| CAN FD 协议编解码 | 自实现 | 中 | 1-2 天 | 低 |
| ENET 以太网 | Fork rt1062-eth-rs + 适配 PHY | **高** | 3-5 天 | **高** |
| smoltcp 集成 | 成熟库 | 低 | 1 天 | 低 |
| Modbus TCP | rmodbus + smoltcp-rmodbus | 低 | 2-3 天 | 低 |
| Modbus RTU RS485 | rmodbus + HAL LPUART + DMA | 中 | 1-2 天 | 低 |
| 标签存储引擎 | 自实现（heapless 数据结构） | 中 | 2-3 天 | 低 |
| 读写器管理 | 自实现 | 中 | 1-2 天 | 低 |
| 消息路由 | 自实现 | 中 | 2-3 天 | 低 |
| Modbus 寄存器映射 | 自实现 | 中 | 2-3 天 | 低 |
| 集成测试 | — | 高 | 3-5 天 | 中 |
| **合计** | | | **~25-40 天** | |

---

## 3. 项目结构

```
rt1060-gateway/
├── .cargo/
│   └── config.toml                 # 编译目标、probe-rs runner、链接脚本
├── Cargo.toml                      # 依赖声明
├── build.rs                        # RuntimeBuilder + 条件链接
├── memory.x                        # （如需自定义内存布局）
│
├── src/
│   ├── main.rs                     # RTIC #[app] 定义，任务入口
│   │
│   ├── bsp.rs                      # 板级支持包
│   │                                 - 引脚分配常量
│   │                                 - 时钟初始化（PLL、CCM）
│   │                                 - PHY 复位 GPIO
│   │
│   ├── can/                        # CAN FD 驱动层
│   │   ├── mod.rs                  # CanFdBus trait + CanFdFrame
│   │   ├── flexcan3.rs             # FlexCAN3 原生 CAN FD 驱动
│   │   │                             - 寄存器初始化
│   │   │                             - 位定时配置（500k/2M）
│   │   │                             - 消息缓冲区（MB）收发
│   │   │                             - 中断处理
│   │   │                             - impl CanFdBus
│   │   └── mcp2518.rs              # MCP2518FD SPI CAN FD 驱动封装
│   │                                 - mcp2518fd crate 集成
│   │                                 - SPI 传输抽象
│   │                                 - INT 引脚中断
│   │                                 - impl CanFdBus
│   │
│   ├── transport/                  # 传输层
│   │   ├── mod.rs
│   │   ├── isotp.rs                # ISO-TP 分帧与重组
│   │   │                             - IsoTpReassembler（单路状态机）
│   │   │                             - IsoTpEngine（4 路并发管理）
│   │   │                             - IsoTpTransmitter（发送端分帧）
│   │   └── session.rs              # Session 管理
│   │                                 - SessionMap：SeqID → pending response
│   │                                 - 超时检测 + 重传计数
│   │
│   ├── protocol/                   # CAN FD 应用层协议
│   │   ├── mod.rs
│   │   ├── can_id.rs               # 29-bit CAN ID 编解码
│   │   ├── pdu.rs                  # 应用层 PDU 帧格式
│   │   ├── tlv.rs                  # 标签 TLV 编解码
│   │   ├── commands.rs             # 命令集定义（枚举 + 参数结构体）
│   │   └── crc.rs                  # CRC16-Modbus 封装
│   │
│   ├── net/                        # 网络层
│   │   ├── mod.rs
│   │   └── enet.rs                 # ENET 驱动（Fork rt1062-eth-rs 适配）
│   │                                 - ENET 初始化
│   │                                 - KSZ8081 PHY 初始化
│   │                                 - DMA 描述符环
│   │                                 - impl smoltcp::phy::Device
│   │                                 - MPU / DCache 配置
│   │
│   ├── modbus/                     # Modbus 上行协议
│   │   ├── mod.rs
│   │   ├── context.rs              # ModbusContext 共享寄存器存储
│   │   ├── registers.rs            # 寄存器地址映射定义（常量 + 读写函数）
│   │   │                             - 网关全局寄存器
│   │   │                             - 读写器控制/状态寄存器
│   │   │                             - 标签邮箱
│   │   │                             - 标签摘要表
│   │   │                             - 线圈 / 离散输入
│   │   ├── tcp.rs                  # Modbus TCP Server
│   │   │                             - smoltcp TCP socket 管理
│   │   │                             - rmodbus TCP 帧处理
│   │   └── rtu.rs                  # Modbus RTU Slave
│   │                                 - LPUART + DMA 配置
│   │                                 - RS485 DE/RE GPIO 控制
│   │                                 - 3.5 字符超时帧边界检测
│   │                                 - rmodbus RTU 帧处理
│   │
│   ├── gateway/                    # 网关核心逻辑
│   │   ├── mod.rs
│   │   ├── tag_store.rs            # 标签存储引擎
│   │   │                             - TagRecord 定义（534B/标签）
│   │   │                             - 静态存储池 [Option<TagRecord>; 256]
│   │   │                             - FNV-1a 哈希索引
│   │   │                             - 去重（按 ReaderType + Field1）
│   │   │                             - RSSI 指数加权滑动均值
│   │   │                             - 老化状态机 New→Updated→Stale→Removed
│   │   │                             - 环形摘要表生成
│   │   ├── reader_mgr.rs           # 读写器管理
│   │   │                             - ReaderState 定义（60 个槽位）
│   │   │                             - 心跳监测（3× 间隔离线判定）
│   │   │                             - 告警收集
│   │   │                             - 配置下发（Modbus 写 → CAN FD 命令）
│   │   └── router.rs               # 消息路由核心
│   │                                 - CAN RX 消息分发
│   │                                 - Modbus 写操作 → CAN FD 命令转换
│   │                                 - 命令超时重传（指数退避）
│   │                                 - 优先级队列
│   │
│   └── util/                       # 工具模块
│       ├── mod.rs
│       └── time.rs                 # 系统时间（基于 GPT monotonic）
│
├── docs/
│   ├── 工业网关通讯数据架构.md      # 协议规范
│   └── 工业网关实施指南.md          # 本文档
│
└── tests/                          # host 端单元测试
    ├── test_can_id.rs              # CAN ID 编解码测试
    ├── test_tlv.rs                 # TLV 编解码测试
    ├── test_isotp.rs               # ISO-TP 分帧/重组测试
    ├── test_crc.rs                 # CRC16 测试
    ├── test_tag_store.rs           # 标签去重/老化测试
    └── test_registers.rs           # Modbus 寄存器映射测试
```

---

## 4. 依赖清单

```toml
[package]
name = "rt1060-gateway"
version = "0.1.0"
edition = "2021"

[features]
default = ["defmt-logging"]
defmt-logging = ["dep:defmt", "dep:defmt-rtt", "dep:panic-probe"]

[dependencies]
# ── Cortex-M 核心 ──
cortex-m = { version = "0.7", features = ["critical-section-single-core"] }
cortex-m-rt = "0.7"

# ── RTIC 并发框架 ──
rtic = { version = "2.2", features = ["thumbv7-backend"] }
rtic-monotonics = { version = "2.1", features = ["imxrt_gpt1"] }
rtic-sync = "2.0"

# ── imxrt 生态 ──
imxrt-ral = { version = "0.5", features = ["imxrt1062", "rt"] }
imxrt-hal = { version = "0.5", features = ["imxrt1060"] }
imxrt-rt = { version = "0.1", features = ["device"] }
imxrt1060evk-fcb = "0.1"

# ── 网络 ──
smoltcp = { version = "0.12", default-features = false, features = [
    "medium-ethernet",
    "proto-ipv4",
    "proto-dhcpv4",
    "socket-tcp",
    "socket-dhcpv4",
] }

# ── Modbus ──
rmodbus = { version = "0.12", default-features = false, features = ["heapless"] }
# smoltcp-rmodbus = "0.1"  # 若版本兼容

# ── CAN FD (Bus2 外挂控制器) ──
mcp2518fd = { git = "https://github.com/adom-inc/mcp2518fd" }
# 备选: mcp2517 = "0.2"

# ── CRC ──
crc = { version = "3.4", default-features = false }

# ── 数据结构 ──
heapless = "0.9"

# ── 日志 ──
defmt = { version = "1.0", optional = true }
defmt-rtt = { version = "1.1", optional = true }
panic-probe = { version = "1.0", features = ["print-defmt"], optional = true }

# ── 无日志时 ──
panic-halt = "0.2"

# ── ENET 驱动 (fork 后本地路径或 git) ──
# imxrt-eth = { path = "../rt1062-eth-rs" }  # 或 git 依赖

[build-dependencies]
imxrt-rt = "0.1"
```

---

## 5. 阶段 0：项目骨架与 RTIC 基础

**目标**：RTIC 空壳在 EVK 上运行，LED 心跳闪烁 + defmt 日志输出。

**预估工时**：1-2 天

### 5.1 详细步骤

1. **创建新 Cargo 工程**

   ```bash
   cargo init rt1060-gateway
   ```

2. **从现有 blinky 项目复制基础文件**

   - `.cargo/config.toml`（编译目标、probe-rs runner、rustflags）
   - `build.rs`（RuntimeBuilder + 条件 defmt.x 链接）
   - FCB 依赖（`imxrt1060evk-fcb`）

3. **编写 `src/main.rs` RTIC 骨架**

   ```rust
   #![no_std]
   #![no_main]

   #[cfg(feature = "defmt-logging")]
   use defmt_rtt as _;
   #[cfg(feature = "defmt-logging")]
   use panic_probe as _;
   #[cfg(not(feature = "defmt-logging"))]
   use panic_halt as _;

   #[cfg(target_arch = "arm")]
   use imxrt1060evk_fcb as _;

   #[rtic::app(
       device = imxrt_ral,
       peripherals = false,
       dispatchers = [KPP, GPIO6_7_8_9]
   )]
   mod app {
       use imxrt_hal as hal;
       use imxrt_ral as ral;
       use rtic_monotonics::imxrt::prelude::*;

       imxrt_gpt1_monotonic!(Mono);

       #[shared]
       struct Shared {}

       #[local]
       struct Local {
           led: hal::gpio::Output<hal::iomuxc::pads::gpio_ad_b0::GPIO_AD_B0_09>,
       }

       #[init]
       fn init(_cx: init::Context) -> (Shared, Local) {
           let mut ccm = unsafe { ral::ccm::CCM::instance() };
           let iomuxc = unsafe { ral::iomuxc::IOMUXC::instance() };
           let gpio1 = unsafe { ral::gpio::GPIO1::instance() };
           let gpt1 = unsafe { ral::gpt::GPT1::instance() };

           // 使能 GPIO1 时钟
           hal::ccm::clock_gate::gpio::<1>().set(&mut ccm, hal::ccm::clock_gate::ON);

           // 配置 LED
           let pads = hal::iomuxc::into_pads(iomuxc);
           let mut gpio1_port = hal::gpio::Port::new(gpio1);
           let led = gpio1_port.output(pads.gpio_ad_b0.p09);

           // 初始化 GPT1 Monotonic（RTIC 定时器）
           // GPT1 时钟频率取决于 CCM 配置，默认 IPG_CLK = 150 MHz
           Mono::start(/* GPT1 实例和时钟频率 */);

           defmt::info!("网关启动");

           // 启动心跳任务
           heartbeat::spawn().ok();

           (Shared {}, Local { led })
       }

       #[task(priority = 1, local = [led])]
       async fn heartbeat(cx: heartbeat::Context) {
           loop {
               cx.local.led.toggle();
               defmt::debug!("heartbeat");
               Mono::delay(500.millis()).await;
           }
       }
   }
   ```

4. **编译并烧录验证**

   ```bash
   cargo build --release
   cargo run --release     # LED 闪烁 + defmt 输出 "网关启动" + "heartbeat"
   ```

### 5.2 验收标准

- [ ] `cargo build --release` 编译通过
- [ ] `cargo run --release` 烧录成功，LED 以 1Hz 闪烁
- [ ] defmt RTT 终端显示 "网关启动" 和周期 "heartbeat" 日志
- [ ] `cargo build --release --no-default-features` 无日志版本也可编译

---

## 6. 阶段 1：FlexCAN3 原生 CAN FD 驱动

**目标**：通过 FlexCAN3 收发 CAN FD 64 字节帧（29-bit 扩展 ID，500k/2M）。

**预估工时**：3-5 天

**参考资料**：
- RT1062 参考手册 Chapter 44 (FlexCAN)
- imxrt-hal PR #171（https://github.com/imxrt-rs/imxrt-hal/pull/171）
- NXP Application Note AN12492 (FlexCAN FD)

### 6.1 FlexCAN3 寄存器关键信息

`imxrt-ral::can3` 模块提供的关键寄存器：

| 寄存器 | 功能 |
|--------|------|
| MCR | 模块控制（Freeze, MDIS, FEN, IRMQ） |
| CTRL1 | 经典 CAN 位定时 + 时钟源 |
| CTRL2 | 高级特性（RFFN, ISOCANFDEN, PREXCEN） |
| CBT | CAN 位定时（扩展，用于仲裁段精确配置） |
| FDCTRL | CAN FD 控制（FDRATE, MBDSR, TDCEN, TDCOFF） |
| FDCBT | CAN FD 数据段位定时 |
| ESR1 | 错误与状态寄存器 |
| IFLAG1/IFLAG2 | 中断标志（MB 0-31 / 32-63） |
| IMASK1/IMASK2 | 中断使能掩码 |
| MB[0..63] | 消息缓冲区（每个 MB 含 CS/ID/DATA 字段） |
| RXIMR[0..63] | 单独 RX 掩码 |

### 6.2 详细实现步骤

**步骤 1：使能 FlexCAN3 时钟**

```rust
// CCM_CCGR0 或对应时钟门控
hal::ccm::clock_gate::can::<3>().set(&mut ccm, hal::ccm::clock_gate::ON);
// 若 HAL 无 CAN 时钟门控便捷函数，用 RAL 直接操作 CCM 寄存器
```

**步骤 2：IOMUXC 引脚配置**

FlexCAN3 TX/RX 引脚需通过 IOMUXC 配置：

| 信号 | 可用引脚（EVK） | ALT |
|------|----------------|-----|
| CAN3_TX | GPIO_EMC_36 | ALT9 |
| CAN3_RX | GPIO_EMC_37 | ALT9 |
| 备选 CAN3_TX | GPIO_AD_B0_00 | ALT8 |
| 备选 CAN3_RX | GPIO_AD_B0_01 | ALT8 |

```rust
// 使用 RAL 直接配置 IOMUXC
ral::write_reg!(ral::iomuxc, iomuxc, SW_MUX_CTL_PAD_GPIO_EMC_36, MUX_MODE: 9);
ral::write_reg!(ral::iomuxc, iomuxc, SW_MUX_CTL_PAD_GPIO_EMC_37, MUX_MODE: 9);
// 配置 pad 电气特性（驱动强度、上拉等）
ral::write_reg!(ral::iomuxc, iomuxc, SW_PAD_CTL_PAD_GPIO_EMC_36,
    DSE: 0b110,   // 驱动强度
    SPEED: 0b10,  // 中速
    SRE: 1         // 快速转换速率
);
```

**步骤 3：FlexCAN3 模块初始化**

```rust
fn init_flexcan3(can3: &ral::can3::CAN3) {
    // 1. 进入 Freeze 模式
    ral::modify_reg!(ral::can3, can3, MCR, MDIS: 0);  // 使能模块
    ral::modify_reg!(ral::can3, can3, MCR, FRZ: 1, HALT: 1);
    while ral::read_reg!(ral::can3, can3, MCR, FRZACK) == 0 {}

    // 2. 配置 MCR
    ral::write_reg!(ral::can3, can3, MCR,
        MDIS: 0,
        FRZ: 1,
        HALT: 1,
        IRMQ: 1,     // 独立 RX 掩码
        SRXDIS: 1,    // 禁止自接收
        // MAXMB 按需设定
    );

    // 3. 配置时钟源和仲裁段位定时 (500 kbps)
    //    假设 CAN 时钟 = 80 MHz (PLL3_SW_CLK / 6)
    //    500k = 80M / (Prescaler × (1 + PropSeg + PhaseSeg1 + PhaseSeg2))
    //    例: Prescaler=2, PROPSEG=7, PSEG1=4, PSEG2=2 → TQ=16, Baud=80M/2/16=2.5M
    //    需精确计算！
    ral::write_reg!(ral::can3, can3, CBT,
        BTF: 1,         // 使用 CBT 而非 CTRL1
        EPRESDIV: 1,    // 分频 = EPRESDIV + 1
        EPROPSEG: 46,   // 传播段
        EPSEG1: 18,     // 相位段 1
        EPSEG2: 12,     // 相位段 2
        ERJW: 12,       // 重同步跳转宽度
    );

    // 4. 使能 CAN FD + 配置数据段位定时 (2 Mbps)
    ral::write_reg!(ral::can3, can3, FDCTRL,
        FDRATE: 1,      // 使能 BRS（位速率切换）
        MBDSR0: 0b11,   // MB 数据大小 = 64 字节
        TDCEN: 1,        // 发送延迟补偿使能
        TDCOFF: 5,       // 延迟补偿偏移
    );

    ral::write_reg!(ral::can3, can3, FDCBT,
        FPRESDIV: 0,    // 分频 = 1
        FPROPSEG: 15,   // 传播段
        FPSEG1: 7,      // 相位段 1
        FPSEG2: 3,      // 相位段 2
        FRJW: 3,        // 重同步跳转宽度
    );

    // 5. 使能 CAN FD ISO 模式
    ral::modify_reg!(ral::can3, can3, CTRL2, ISOCANFDEN: 1);

    // 6. 配置消息缓冲区
    //    MB0-7: 接收缓冲区（配置 RX 过滤器）
    //    MB8:   发送缓冲区
    configure_rx_mbs(can3);
    configure_tx_mb(can3);

    // 7. 配置接收过滤器（接受所有 29-bit 扩展帧）
    for i in 0..8 {
        // 全局掩码或独立掩码
        ral::write_reg!(ral::can3, can3, RXIMR[i], 0x00000000); // 接受所有
    }

    // 8. 使能接收中断
    ral::write_reg!(ral::can3, can3, IMASK1, 0x000000FF); // MB0-7 中断使能

    // 9. 退出 Freeze 模式
    ral::modify_reg!(ral::can3, can3, MCR, FRZ: 0, HALT: 0);
    while ral::read_reg!(ral::can3, can3, MCR, FRZACK) != 0 {}
}
```

**步骤 4：帧发送实现**

```rust
fn can3_send(can3: &ral::can3::CAN3, id: u32, data: &[u8], brs: bool) -> Result<(), CanError> {
    let tx_mb = 8;  // 使用 MB8 作为发送缓冲

    // 等待 MB 空闲
    let cs = read_mb_cs(can3, tx_mb);
    if (cs >> 24) & 0xF == 0x8 { /* TX pending, 等待或返回 Busy */ }

    // 写入 ID（29-bit 扩展帧）
    write_mb_id(can3, tx_mb, id | (1 << 29));  // IDE 位

    // 写入数据（64 字节，补零）
    let mut buf = [0u8; 64];
    let len = data.len().min(64);
    buf[..len].copy_from_slice(&data[..len]);
    write_mb_data(can3, tx_mb, &buf);

    // 写入 CS（触发发送）
    let dlc = len_to_dlc(len);
    let mut cs_val: u32 = 0;
    cs_val |= 0x0C << 24;  // CODE = TX_DATA (0b1100)
    cs_val |= 1 << 21;     // IDE = 1 (扩展帧)
    cs_val |= 1 << 22;     // SRR = 1
    cs_val |= (dlc as u32) << 16;
    if brs { cs_val |= 1 << 30; }  // BRS
    cs_val |= 1 << 31;     // EDL = 1 (FD 帧)
    write_mb_cs(can3, tx_mb, cs_val);

    Ok(())
}

/// CAN FD DLC 映射
fn len_to_dlc(len: usize) -> u8 {
    match len {
        0..=8 => len as u8,
        9..=12 => 9,
        13..=16 => 10,
        17..=20 => 11,
        21..=24 => 12,
        25..=32 => 13,
        33..=48 => 14,
        49..=64 => 15,
        _ => 15,
    }
}
```

**步骤 5：接收中断处理**

```rust
// RTIC 中断任务
#[task(binds = CAN3, priority = 4, local = [can3], shared = [can_rx_queue])]
fn can3_irq(cx: can3_irq::Context) {
    let can3 = cx.local.can3;
    let iflag = ral::read_reg!(ral::can3, can3, IFLAG1);

    for mb in 0..8 {
        if iflag & (1 << mb) != 0 {
            // 读取 CS
            let cs = read_mb_cs(can3, mb);
            let code = (cs >> 24) & 0xF;
            if code == 0x2 {  // FULL (有新帧)
                let id = read_mb_id(can3, mb) & 0x1FFF_FFFF;
                let dlc = ((cs >> 16) & 0xF) as u8;
                let len = dlc_to_len(dlc);
                let brs = (cs >> 30) & 1 != 0;

                let mut frame = CanFdFrame::default();
                frame.id = id;
                frame.len = len as u8;
                frame.brs = brs;
                read_mb_data(can3, mb, &mut frame.data[..len]);

                // 推入无锁队列
                cx.shared.can_rx_queue.lock(|q| {
                    let _ = q.enqueue(frame);  // 满则丢弃（日志记录）
                });
            }
            // 清除中断标志
            ral::write_reg!(ral::can3, can3, IFLAG1, 1 << mb);
        }
    }

    // 读取 Timer 寄存器解锁 MB（FlexCAN 要求）
    let _ = ral::read_reg!(ral::can3, can3, TIMER);
}
```

### 6.3 验收标准

- [ ] FlexCAN3 初始化无挂起
- [ ] 可通过 CAN 分析仪观测到 500k/2M CAN FD 帧
- [ ] 接收外部 CAN FD 帧并通过 defmt 打印 ID + 数据
- [ ] 64 字节满载收发正确
- [ ] 总线错误恢复（拔线再插，自动恢复）

---

## 7. 阶段 2：SPI + MCP2518FD 第二路 CAN FD

**目标**：通过 LPSPI + MCP2518FD 外挂控制器实现第二路 CAN FD。

**预估工时**：2-3 天

### 7.1 硬件接线

| MCP2518FD 引脚 | EVK 连接 | RT1062 引脚 | 说明 |
|---------------|---------|-------------|------|
| SCK | LPSPI2_SCK | GPIO_SD_B1_07 | SPI 时钟 |
| SDI (MOSI) | LPSPI2_SDO | GPIO_SD_B1_08 | SPI 数据入 |
| SDO (MISO) | LPSPI2_SDI | GPIO_SD_B1_09 | SPI 数据出 |
| CS | GPIO | GPIO_SD_B1_06 或任意 GPIO | 片选 |
| INT | GPIO 中断 | 任意 GPIO（配置下降沿中断） | 接收通知 |
| RST | GPIO | 任意 GPIO | 硬件复位 |

### 7.2 详细实现步骤

**步骤 1：LPSPI2 初始化**

```rust
let lpspi2 = unsafe { ral::lpspi::LPSPI2::instance() };
hal::ccm::clock_gate::lpspi::<2>().set(&mut ccm, hal::ccm::clock_gate::ON);
let spi_pins = hal::lpspi::Pins {
    sck: pads.gpio_sd_b1.p07,
    sdo: pads.gpio_sd_b1.p08,
    sdi: pads.gpio_sd_b1.p09,
    pcs0: pads.gpio_sd_b1.p06,
};
let mut spi = hal::lpspi::Lpspi::new(lpspi2, spi_pins);
spi.disabled(|spi| {
    spi.set_clock_hz(LPSPI_CLK_HZ, 10_000_000);  // MCP2518 支持最高 20MHz SPI
    spi.set_mode(embedded_hal::spi::MODE_0);
});
```

**步骤 2：MCP2518FD 初始化**

```rust
use mcp2518fd::MCP2518FD;

let mut mcp = MCP2518FD::new(spi);
mcp.reset()?;
delay_ms(5);

// 配置 CAN FD 位定时：500k 仲裁 + 2M 数据
mcp.configure_bit_timing(/* 按 MCP2518FD 寄存器格式 */)?;

// 配置 FIFO
mcp.configure_tx_fifo(/* ... */)?;
mcp.configure_rx_fifo(/* ... */)?;

// 配置过滤器（接受所有扩展帧）
mcp.configure_filter(0, 0x00000000, 0x00000000)?;

// 使能中断
mcp.enable_rx_interrupt()?;

// 进入 Normal 模式
mcp.set_mode(OperationMode::NormalFD)?;
```

**步骤 3：统一接口封装**

```rust
pub struct Mcp2518Bus {
    mcp: MCP2518FD<Lpspi2Type>,
}

impl CanFdBus for Mcp2518Bus {
    type Error = mcp2518fd::Error;

    fn send(&mut self, id: u32, data: &[u8], brs: bool) -> Result<(), Self::Error> {
        let frame = /* 构建 mcp2518fd Frame */;
        self.mcp.transmit(frame)
    }

    fn try_recv(&mut self) -> Result<Option<CanFdFrame>, Self::Error> {
        match self.mcp.receive() {
            Ok(frame) => Ok(Some(convert_to_canfd_frame(frame))),
            Err(mcp2518fd::Error::NoMessage) => Ok(None),
            Err(e) => Err(e),
        }
    }

    fn bus_state(&self) -> BusState { /* 读取 MCP2518 状态寄存器 */ }
}
```

**步骤 4：INT 引脚 GPIO 中断**

```rust
// MCP2518FD INT 引脚配置为 GPIO 输入 + 下降沿中断
// RTIC 中通过 GPIO 中断触发接收处理

#[task(binds = GPIO2_COMBINED_16_31, priority = 4, local = [mcp_bus], shared = [can_rx_queue])]
fn mcp_int(cx: mcp_int::Context) {
    // 清除 GPIO 中断标志
    // 从 MCP2518FD 读取所有就绪帧
    while let Ok(Some(frame)) = cx.local.mcp_bus.try_recv() {
        cx.shared.can_rx_queue.lock(|q| {
            let _ = q.enqueue((1, frame));  // bus=1 标识 Bus2
        });
    }
}
```

### 7.3 验收标准

- [ ] MCP2518FD 通过 SPI 正常通信（读取寄存器验证）
- [ ] Bus2 CAN FD 收发正常（64 字节）
- [ ] Bus1 (FlexCAN3) 和 Bus2 (MCP2518) 独立工作互不干扰
- [ ] 两条总线同时收发无数据错乱

---

## 8. 阶段 3：CAN FD 协议栈

**目标**：实现架构文档定义的完整 CAN FD 应用层协议。

**预估工时**：2-3 天

**此阶段纯逻辑代码，可在 host 上 `cargo test` 测试。**

### 8.1 详细实现步骤

**步骤 1：CAN ID 编解码** (`src/protocol/can_id.rs`)

- `CanFdId` 结构体：priority/msg_type/func_code/dest_id/source_id
- `encode() -> u32` 和 `decode(u32) -> Self`
- 单元测试覆盖边界值

**步骤 2：应用层 PDU** (`src/protocol/pdu.rs`)

- `AppPdu` 结构体：seq_id/sub_cmd/status/data_len/data/crc16
- `encode(&self, buf: &mut [u8]) -> usize`
- `decode(buf: &[u8]) -> Result<Self, PduError>`
- CRC16 计算与校验集成

**步骤 3：TLV 标签编解码** (`src/protocol/tlv.rs`)

- `TagTlv` 结构体（含 phase_start/phase_end）
- `encode()` / `decode()` 方法
- 批量标签打包（多个 TLV 连续排列）
- 单元测试：LF/HF/UHF 各种长度组合

**步骤 4：ISO-TP 引擎** (`src/transport/isotp.rs`)

- 发送端：`IsoTpTransmitter`
  - `start_send(data: &[u8]) -> Vec<CanFdFrame>`：生成分帧序列
  - 处理 Flow Control 响应
- 接收端：`IsoTpReassembler`
  - `feed(frame: &CanFdFrame) -> IsoTpResult`
  - 状态机：Idle → WaitingFC → Receiving → Complete
  - 超时检测（500ms 无后续帧 → 丢弃）
- 并发管理：`IsoTpEngine`（4 路 slot）

**步骤 5：命令集定义** (`src/protocol/commands.rs`)

- 枚举所有 FuncCode
- 每条命令的参数/响应结构体
- 序列化/反序列化方法

### 8.2 验收标准

- [ ] `cargo test` 全部通过（host 端）
- [ ] CAN ID 编解码往返一致性
- [ ] TLV 编解码支持 0-256 字节变长字段
- [ ] ISO-TP 分帧/重组：512B 数据正确分拆 + 重组
- [ ] CRC16 与 Python/C 实现计算结果一致

---

## 9. 阶段 4：以太网 ENET 驱动

**目标**：ENET + KSZ8081 PHY + smoltcp 网络栈，实现 IP 通信。

**预估工时**：3-5 天

### 9.1 详细实现步骤

**步骤 1：Fork 并适配 rt1062-eth-rs**

```bash
git clone https://github.com/Timvrakas/rt1062-eth-rs
# 修改 PHY 初始化代码，从 DP83825I 改为 KSZ8081
# 升级 smoltcp 依赖至 0.12
```

**步骤 2：ENET 时钟与引脚配置**

```rust
fn init_enet_clocks(ccm: &mut ral::ccm::CCM) {
    // 使能 ENET 时钟门控
    hal::ccm::clock_gate::enet().set(ccm, hal::ccm::clock_gate::ON);

    // 配置 ENET_REF_CLK = 50 MHz
    // PLL6 (ENET PLL) → 50 MHz 分频
    // 或使用外部 50MHz 晶振（取决于 EVK 硬件设计）
}

fn init_enet_pins(iomuxc: &ral::iomuxc::IOMUXC) {
    // 按 7.2 中的引脚映射表配置 IOMUXC
    // 每个引脚设置 ALT 模式 + pad 电气特性
    // ENET_TX_CLK 需要特殊配置（SION 位使能回环）
}
```

**步骤 3：KSZ8081 PHY 初始化**

按 1.3.4 节中的初始化序列实现。

**步骤 4：DMA 描述符与 DCache**

```rust
// 将 DMA 缓冲区放在 OCRAM2 的固定地址
#[link_section = ".dma_buffers"]
static mut RX_DESC: [RxDescriptor; 12] = [RxDescriptor::EMPTY; 12];
#[link_section = ".dma_buffers"]
static mut TX_DESC: [TxDescriptor; 12] = [TxDescriptor::EMPTY; 12];
#[link_section = ".dma_buffers"]
static mut RX_BUFS: [[u8; 1536]; 12] = [[0; 1536]; 12];
#[link_section = ".dma_buffers"]
static mut TX_BUFS: [[u8; 1536]; 12] = [[0; 1536]; 12];

// 在链接脚本中定义 .dma_buffers 段放置于非缓存内存区域
// 或用 MPU 配置该区域为 Non-cacheable
```

**步骤 5：smoltcp 集成**

```rust
let mut device = EnetDevice::new(enet, &mut rx_desc, &mut tx_desc, &mut rx_bufs, &mut tx_bufs);
init_ksz8081(&mut device);

let config = Config::new(EthernetAddress([0x02, 0x00, 0x00, 0x00, 0x00, 0x01]).into());
let mut iface = Interface::new(config, &mut device, Instant::ZERO);
iface.update_ip_addrs(|addrs| {
    addrs.push(IpCidr::new(Ipv4Address::new(192, 168, 1, 100).into(), 24)).unwrap();
});
```

### 9.2 验收标准

- [ ] PHY 链路建立（defmt 打印 "PHY link up"）
- [ ] `ping 192.168.1.100` 从 PC 端响应正常
- [ ] DHCP 获取 IP 地址（可选）
- [ ] TCP 连接建立与数据收发

---

## 10. 阶段 5：Modbus TCP Server

**目标**：上位机通过 Modbus TCP 读写网关寄存器。

**预估工时**：2-3 天

### 10.1 详细实现步骤

**步骤 1：Modbus 寄存器存储**

```rust
// src/modbus/context.rs
use rmodbus::server::context::ModbusContext;

// rmodbus ModbusContext 大小配置
// 默认: 10000 coils + 10000 DI + 10000 Input + 10000 Holding
// 可自定义
pub static mut MODBUS_CTX: ModbusContext = ModbusContext::new();
```

**步骤 2：寄存器地址映射**

```rust
// src/modbus/registers.rs

// ── 网关全局 ──
pub const GW_FW_VERSION_MAJOR: u16 = 0x0000;
pub const GW_FW_VERSION_MINOR: u16 = 0x0001;
pub const GW_UPTIME_H: u16 = 0x0004;
pub const GW_UPTIME_L: u16 = 0x0005;
// ...

// ── 读写器控制 ──
pub const fn reader_holding_base(index: u8) -> u16 { 0x0100 + (index as u16) * 0x0080 }
pub const fn reader_input_base(index: u8) -> u16 { 0x0100 + (index as u16) * 0x0040 }

// ── 标签邮箱 ──
pub const MB_TAG_INDEX: u16 = 0x2000;
pub const MB_FIELD_SEL: u16 = 0x2001;
pub const MB_OFFSET: u16 = 0x2002;
pub const MB_TRIGGER: u16 = 0x2003;
pub const MB_STATUS: u16 = 0x2010;
// ...

// ── 标签摘要 ──
pub const fn tag_summary_base(index: u16) -> u16 { 0x3000 + index * 10 }

/// 将 TagStore 数据同步到 Modbus 输入寄存器
pub fn sync_tag_store_to_modbus(store: &TagStore, ctx: &mut ModbusContext) {
    // 更新在场标签数
    ctx.set_input(0x0003, store.count as u16);
    // 更新每个标签摘要
    for (i, record) in store.iter().enumerate() {
        let base = tag_summary_base(i as u16);
        ctx.set_input(base + 0, ((record.reader_type as u16) << 4) | (record.state as u16));
        ctx.set_input(base + 1, ((record.reader_id as u16) << 8) | (record.antenna as u16));
        ctx.set_input(base + 2, record.rssi as u16);
        ctx.set_input(base + 3, record.read_count);
        ctx.set_input(base + 4, record.phase_start);
        ctx.set_input(base + 5, record.phase_end);
        // Field1 前 4 字节
        ctx.set_input(base + 6, u16::from_be_bytes([record.field1.data[0], record.field1.data[1]]));
        ctx.set_input(base + 7, u16::from_be_bytes([record.field1.data[2], record.field1.data[3]]));
        ctx.set_input(base + 8, (record.last_seen >> 16) as u16);
        ctx.set_input(base + 9, record.last_seen as u16);
    }
}
```

**步骤 3：TCP Server 主循环**

```rust
// src/modbus/tcp.rs
fn poll_modbus_tcp(sockets: &mut SocketSet, tcp_handle: SocketHandle) {
    let socket = sockets.get_mut::<tcp::Socket>(tcp_handle);

    if !socket.is_active() && !socket.is_listening() {
        socket.listen(502).unwrap();
    }

    if socket.can_recv() {
        let mut request = [0u8; 260];
        let n = socket.recv_slice(&mut request).unwrap();
        if n > 0 {
            let mut response: heapless::Vec<u8, 260> = heapless::Vec::new();
            handle_modbus_tcp(&request[..n], &mut response);
            if !response.is_empty() {
                socket.send_slice(&response).unwrap();
            }
        }
    }
}
```

**步骤 4：邮箱写入触发**

```rust
/// 监听 Holding 寄存器写入，触发邮箱加载
fn check_mailbox_trigger(ctx: &ModbusContext, store: &TagStore, ctx_mut: &mut ModbusContext) {
    let trigger = ctx.get_holding(MB_TRIGGER);
    if trigger != 0 {
        let index = ctx.get_holding(MB_TAG_INDEX) as usize;
        let field_sel = ctx.get_holding(MB_FIELD_SEL);
        let offset = ctx.get_holding(MB_OFFSET) as usize;

        // 清除触发
        ctx_mut.set_holding(MB_TRIGGER, 0);

        if let Some(record) = store.get(index) {
            // 填充邮箱数据窗口
            ctx_mut.set_holding(MB_STATUS, 1);  // Ready
            ctx_mut.set_holding(0x2011, record.reader_type as u16);
            ctx_mut.set_holding(0x2012, record.reader_id as u16);
            // ... 填充所有字段 ...
            load_field_to_window(ctx_mut, 0x2021, &record.field1, offset);
            load_field_to_window(ctx_mut, 0x2091, &record.field2, offset);
        } else {
            ctx_mut.set_holding(MB_STATUS, 0xFF);  // Invalid
        }
    }
}
```

### 10.2 验收标准

- [ ] PC 端 Modbus Poll 连接 192.168.1.100:502 成功
- [ ] FC03 读保持寄存器：返回固件版本
- [ ] FC04 读输入寄存器：返回在线读写器数、标签数
- [ ] FC05/06 写线圈/寄存器：控制盘点启停
- [ ] 标签邮箱：写入索引 → 读出标签完整数据

---

## 11. 阶段 6：Modbus RTU (RS485)

**目标**：通过 RS485 串口实现 Modbus RTU 从站，与 TCP 共享寄存器。

**预估工时**：1-2 天

### 11.1 详细实现步骤

**步骤 1：LPUART + RS485 硬件配置**

```rust
let lpuart3 = unsafe { ral::lpuart::LPUART3::instance() };
hal::ccm::clock_gate::lpuart::<3>().set(&mut ccm, hal::ccm::clock_gate::ON);

let uart_pins = hal::lpuart::Pins {
    tx: pads.gpio_ad_b1.p06,  // LPUART3_TX
    rx: pads.gpio_ad_b1.p07,  // LPUART3_RX
};
let mut uart = hal::lpuart::Lpuart::new(lpuart3, uart_pins);
uart.disable(|uart| {
    uart.set_baud(&hal::lpuart::Baud::compute(UART_CLK, 115200));
    uart.set_parity(None);
    // 使能 RX 中断
    uart.set_interrupts(hal::lpuart::Interrupts::RECEIVE_FULL);
});

// DE/RE 引脚配置为 GPIO 输出
let mut de_pin = gpio_port.output(pads.gpio_ad_b1.p08);
de_pin.clear();  // 默认接收模式（DE=0, RE=0）
```

**步骤 2：3.5 字符超时帧边界检测**

```rust
// 使用 PIT 定时器检测帧结束
// 115200 baud: 1 字符 = 11 bit / 115200 = 95.5 μs
// 3.5 字符 = 334 μs
const FRAME_TIMEOUT_US: u32 = 350;  // 3.5 字符时间

// 每收到一个字节，重置 PIT 定时器
// PIT 超时触发 → 帧接收完成 → 处理 RTU 帧

#[task(binds = LPUART3, priority = 3, local = [uart, rx_buf, rx_pos, pit_ch])]
fn uart_rx(cx: uart_rx::Context) {
    let uart = cx.local.uart;
    while let Ok(byte) = uart.read_data() {
        cx.local.rx_buf[*cx.local.rx_pos] = byte as u8;
        *cx.local.rx_pos += 1;
        // 重置帧超时定时器
        cx.local.pit_ch.set_load_timer_value(FRAME_TIMEOUT_TICKS);
        cx.local.pit_ch.enable();
    }
}

#[task(binds = PIT, priority = 3, local = [/*...*/], shared = [modbus_ctx])]
fn frame_timeout(cx: frame_timeout::Context) {
    // PIT 超时 → 帧接收完成
    // 处理 RTU 帧
    let request = &rx_buf[..rx_pos];
    let mut response: heapless::Vec<u8, 256> = heapless::Vec::new();
    handle_modbus_rtu(request, &mut response);
    if !response.is_empty() {
        de_pin.set();  // 切换到发送模式
        uart.dma_write(dma_ch, &response);
        // DMA 完成后切回接收模式
        de_pin.clear();
    }
    rx_pos = 0;  // 重置接收缓冲
}
```

**步骤 3：RTU 帧处理**

```rust
fn handle_modbus_rtu(request: &[u8], response: &mut heapless::Vec<u8, 256>) {
    let mut frame = ModbusFrame::new(
        MODBUS_SLAVE_ADDR,
        request,
        rmodbus::ModbusProto::Rtu,
        response,
    );
    if frame.parse().is_ok() && frame.processing_required {
        // 同 TCP 处理逻辑，共享同一个 ModbusContext
        // ...
        frame.finalize_response();
    }
}
```

### 11.2 验收标准

- [ ] USB-RS485 转换器 + Modbus RTU 主站连接成功
- [ ] FC03/04 读寄存器返回正确数据
- [ ] TCP 和 RTU 同时连接，数据一致
- [ ] 波特率切换（9600/115200）工作正常

---

## 12. 阶段 7：网关核心逻辑

**目标**：完成标签引擎、读写器管理、消息路由。

**预估工时**：3-4 天

### 12.1 标签存储引擎详细设计

```rust
// src/gateway/tag_store.rs

const MAX_TAGS: usize = 256;
const HASH_BUCKETS: usize = 512;  // 2× 标签数，减少碰撞

pub struct TagStore {
    records: [Option<TagRecord>; MAX_TAGS],
    count: usize,
    hash_index: [u16; HASH_BUCKETS],  // hash → slot_index (0xFFFF = 空)
    stale_timeout_ms: u32,
    remove_timeout_ms: u32,
}

impl TagStore {
    /// 插入或更新标签
    pub fn upsert(&mut self, tlv: &TagTlv, reader_id: u8, bus: u8, now_ms: u32) {
        let hash = tag_hash(tlv.tag_type, &tlv.field1);
        let bucket = (hash as usize) % HASH_BUCKETS;

        // 查找已有记录
        if let Some(slot) = self.find_by_hash(bucket, tlv.tag_type, &tlv.field1) {
            // 更新已有记录
            let record = self.records[slot].as_mut().unwrap();
            record.rssi = rssi_ewma(record.rssi, tlv.rssi);
            record.phase_start = tlv.phase_start;
            record.phase_end = tlv.phase_end;
            record.read_count = record.read_count.saturating_add(1);
            record.last_seen = now_ms;
            record.state = TagState::Updated;
            // 更新 Field2（可能变化的 EPC/User 数据）
            record.field2 = tlv.field2.clone();
        } else {
            // 插入新记录
            if let Some(slot) = self.find_free_slot() {
                self.records[slot] = Some(TagRecord::from_tlv(tlv, reader_id, bus, now_ms));
                self.hash_index[bucket] = slot as u16;
                self.count += 1;
            } else {
                // 存储满：LRU 淘汰最久未更新的 Stale/Removed 标签
                self.evict_oldest_stale();
            }
        }
    }

    /// 老化处理（定时调用）
    pub fn age(&mut self, now_ms: u32) {
        for record in self.records.iter_mut().flatten() {
            let elapsed = now_ms.wrapping_sub(record.last_seen);
            match record.state {
                TagState::New | TagState::Updated => {
                    if elapsed > self.stale_timeout_ms {
                        record.state = TagState::Stale;
                    }
                }
                TagState::Stale => {
                    if elapsed > self.remove_timeout_ms {
                        record.state = TagState::Removed;
                    }
                }
                TagState::Removed => {
                    // 下一轮清除
                }
            }
        }
    }

    /// RSSI 指数加权移动平均
    fn rssi_ewma(old: i16, new: i16) -> i16 {
        // alpha = 0.3 (新值权重 30%)
        // 使用整数运算避免浮点
        ((old as i32 * 7 + new as i32 * 3) / 10) as i16
    }
}
```

### 12.2 消息路由核心

```rust
// src/gateway/router.rs

pub struct MessageRouter {
    // 命令重传管理
    pending_commands: [Option<PendingCommand>; 16],
    session_counter: u8,
}

struct PendingCommand {
    reader_id: u8,
    bus: u8,
    seq_id: u8,
    func_code: u8,
    frame_data: heapless::Vec<u8, 64>,
    sent_at: u32,
    retry_count: u8,
    timeout_ms: u32,
}

impl MessageRouter {
    /// 处理 CAN FD 接收帧
    pub fn handle_can_rx(
        &mut self,
        bus: u8,
        frame: &CanFdFrame,
        tag_store: &mut TagStore,
        reader_mgr: &mut ReaderManager,
        now_ms: u32,
    ) {
        let can_id = CanFdId::decode(frame.id);

        match can_id.msg_type {
            MsgType::TAG_SINGLE | MsgType::TAG_STREAM => {
                // 解码 PDU，校验 CRC
                if let Ok(pdu) = AppPdu::decode(&frame.data[..frame.len as usize]) {
                    if !pdu.verify_crc() {
                        defmt::warn!("CRC 校验失败: reader={}", can_id.source_id);
                        return;
                    }
                    // 解码 TLV 标签
                    let mut offset = 0;
                    while offset < pdu.data.len() {
                        if let Some((tlv, consumed)) = TagTlv::decode(&pdu.data[offset..]) {
                            tag_store.upsert(&tlv, can_id.source_id, bus, now_ms);
                            offset += consumed;
                        } else {
                            break;
                        }
                    }
                }
            }
            MsgType::HEARTBEAT => {
                reader_mgr.handle_heartbeat(can_id.source_id, bus, &frame.data, now_ms);
            }
            MsgType::CMD_RSP => {
                self.match_response(can_id.source_id, &frame.data);
            }
            MsgType::ALARM => {
                reader_mgr.handle_alarm(can_id.source_id, bus, &frame.data);
            }
            MsgType::MFRM_START | MsgType::MFRM_CONT => {
                // 转发给 ISO-TP 引擎处理
            }
            _ => {}
        }
    }

    /// Modbus 写操作 → CAN FD 命令转发
    pub fn forward_modbus_to_can(
        &mut self,
        reader_index: u8,
        func_code: u8,
        params: &[u8],
        readers: &ReaderManager,
        can_buses: &mut [&mut dyn CanFdBus],
        now_ms: u32,
    ) {
        if let Some(reader) = readers.get(reader_index) {
            let seq_id = self.next_session();
            let pdu = AppPdu::new_request(seq_id, func_code, params);
            let mut buf = [0u8; 64];
            let len = pdu.encode(&mut buf);

            let can_id = CanFdId {
                priority: 3,
                msg_type: MsgType::CMD_REQ,
                func_code,
                dest_id: reader.id,
                source_id: 0x00,  // 网关
            };

            let bus_idx = reader.bus as usize;
            can_buses[bus_idx].send(can_id.encode(), &buf[..len], true).ok();

            // 记录待确认命令
            self.register_pending(reader.id, reader.bus, seq_id, func_code, &buf[..len], now_ms);
        }
    }

    /// 超时重传检查（定期调用）
    pub fn check_timeouts(&mut self, can_buses: &mut [&mut dyn CanFdBus], now_ms: u32) {
        for slot in self.pending_commands.iter_mut() {
            if let Some(cmd) = slot {
                let elapsed = now_ms.wrapping_sub(cmd.sent_at);
                let timeout = cmd.timeout_ms * (1 << cmd.retry_count);  // 指数退避
                if elapsed > timeout {
                    if cmd.retry_count < 3 {
                        // 重传
                        let bus_idx = cmd.bus as usize;
                        can_buses[bus_idx].send(/* ... */).ok();
                        cmd.retry_count += 1;
                        cmd.sent_at = now_ms;
                        defmt::warn!("重传: reader={}, retry={}", cmd.reader_id, cmd.retry_count);
                    } else {
                        // 放弃
                        defmt::error!("命令超时: reader={}, func=0x{:02X}", cmd.reader_id, cmd.func_code);
                        *slot = None;
                    }
                }
            }
        }
    }
}
```

### 12.3 验收标准

- [ ] 模拟读写器发送标签 TLV → 网关 TagStore 正确存储
- [ ] 重复标签自动去重，RSSI 更新
- [ ] 标签老化状态机正常流转
- [ ] 心跳超时 → 读写器离线 → Modbus 状态更新
- [ ] Modbus 写盘点启动 → CAN FD 命令正确下发
- [ ] 命令无响应 → 自动重传 3 次 → 报错

---

## 13. 阶段 8：集成测试与调优

**目标**：全链路端到端验证，压力测试，故障注入。

**预估工时**：3-5 天

### 13.1 测试矩阵

| 测试项 | 方法 | 预期结果 |
|--------|------|---------|
| 单读写器标签上报 | CAN 分析仪模拟单台 UHF 读写器 | Modbus 可读取标签数据 |
| 多读写器并发 | 双总线各 3 台模拟读写器同时盘点 | 所有标签正确汇聚 |
| 变长字段 | 发送 256B TID + 256B EPC（多帧） | ISO-TP 重组正确 |
| CRC 错误注入 | 发送 CRC 错误帧 | 网关丢弃，日志记录 |
| 读写器断线 | 停止心跳 3 秒 | Modbus 显示离线 |
| 读写器重连 | 恢复心跳 | 自动恢复在线 |
| CAN 总线断开 | 物理断开 Bus1 | Bus1 读写器离线，Bus2 不受影响 |
| 以太网断开 | 拔网线 10 秒 | Modbus TCP 断开，RTU 正常，重连后恢复 |
| 标签存储满 | 注入 >256 标签 | LRU 淘汰 + TAG_OVERFLOW 标志 |
| 带宽压力 | Bus1 满载 2500 帧/秒 | CPU 占用 < 30%，无丢帧 |
| 看门狗 | 人为死循环某任务 | RTWDOG 触发硬件复位 |
| 长时间运行 | 72 小时无人值守 | 无内存泄漏、无 panic、计数器正常 |

### 13.2 调优要点

| 调优项 | 方法 |
|--------|------|
| CAN 接收丢帧 | 增大 spsc::Queue 容量 / 提高中断优先级 |
| smoltcp 响应慢 | 增大 TCP 缓冲区 / 调整轮询频率 |
| 标签去重慢 | 优化哈希函数 / 增大桶数 |
| DMA 传输错误 | 检查 DCache 一致性 / MPU 配置 |
| 功耗优化 | 空闲时 WFI / 降低 smoltcp 轮询频率 |

---

## 14. 依赖关系与关键路径

```
阶段 0 (RTIC 骨架, 1-2d)
  │
  ├──→ 阶段 1 (FlexCAN3, 3-5d) ──┐
  │                                 ├──→ 阶段 3 (协议栈, 2-3d) ──┐
  ├──→ 阶段 2 (MCP2518, 2-3d) ───┘                               │
  │                                                                │
  ├──→ 阶段 4 (ENET, 3-5d) ──→ 阶段 5 (Modbus TCP, 2-3d) ──────┤
  │                                                                │
  └──→ 阶段 6 (Modbus RTU, 1-2d) ────────────────────────────────┤
                                                                   │
                                                                   ▼
                                          阶段 7 (网关核心, 3-4d)
                                                   │
                                                   ▼
                                          阶段 8 (集成测试, 3-5d)

关键路径: 0 → 1 → 3 → 7 → 8 (总计 12-19 天)
总工期（含并行）: 约 25-40 天
```

**可并行的工作流**：
- 阶段 1 (FlexCAN3) + 阶段 4 (ENET) + 阶段 6 (Modbus RTU) 可同时进行
- 阶段 3 (协议栈) 的单元测试可在 host 上并行开发
- 阶段 2 (MCP2518) 在阶段 1 完成后立即开始

---

## 15. 风险分析与应对

| 风险 | 可能性 | 影响 | 应对措施 |
|------|--------|------|---------|
| FlexCAN3 CAN FD 驱动开发困难 | 高 | 高 | 1. 参考 PR #171 代码结构 2. 先实现 CAN 2.0 验证链路再升级 FD 3. 必要时仅用 8 字节帧降级运行 |
| MCP2518FD 驱动 crate 存在 bug | 中 | 中 | 1. 备选 `mcp2517` crate 2. 基于 SPI 寄存器手写核心功能 3. Fork 后修复 |
| ENET PHY (KSZ8081) 初始化失败 | 中 | 高 | 1. 参考 NXP C SDK fsl_phy_ksz8081 驱动 2. 用示波器验证 RMII 信号 3. 检查 50MHz REF_CLK |
| DCache 与 DMA 一致性问题 | 高 | 高 | 1. MPU 配置非缓存区域（首选） 2. 手动 SCB clean/invalidate 3. 禁用 DCache（最后手段，影响性能） |
| smoltcp 版本与 rmodbus/eth 不兼容 | 中 | 中 | 1. 统一 smoltcp 0.12 2. 自实现 Modbus TCP 帧处理替代 smoltcp-rmodbus |
| ISO-TP 第三方库不可靠 | 低 | 低 | 自实现（推荐，仅 ~300 行代码） |
| CAN FD 生态无标准 trait | 确定 | 低 | 自定义 `CanFdBus` trait，统一两路 CAN 接口 |
| RTIC 与 imxrt-ral 中断名不匹配 | 低 | 中 | 检查 ral Interrupt 枚举，必要时自定义 extern "C" fn |
| 标签存储 256 个不够 | 低 | 中 | 减小 TagRecord 大小（按需裁剪 VarField 最大长度） |
| 工期超预期 | 中 | — | CAN FD 和 ENET 是最大不确定性，预留 50% buffer |

---

> **文档结束**
> 总预估工期：25-40 天（含并行开发）
> 关键路径：FlexCAN3 CAN FD 驱动 → 协议栈 → 网关核心 → 集成测试
> 最大风险：FlexCAN3 和 ENET 驱动的自研工作量
